/****************************************************** *****************************
 *
 * حقوق الطبع والنشر 2014 لشركة Paphus Solutions Inc.
 *
 * مرخص بموجب ترخيص Eclipse Public License، الإصدار 1.0 (المشار إليه فيما يلي باسم "الترخيص")؛
 * لا يجوز لك استخدام هذا الملف إلا بما يتوافق مع الترخيص.
 * يمكنك الحصول على نسخة من الترخيص من خلال
 *
 * http://www.Eclipse.org/legal/epl-v10.html
 *
 * ما لم يكن ذلك مطلوبًا بموجب القانون المعمول به أو متفق عليه كتابيًا، فإن البرنامج
 * يتم توزيعه بموجب الترخيص على أساس "كما هو"،
 * بدون أي ضمانات أو شروط من أي نوع، سواء صريحة أو ضمنية.
 * راجع الترخيص لمعرفة اللغة المحددة التي تحكم الأذونات و
 * القيود بموجب الترخيص.
 *
 *************************************************************************************************************************************************************************** ***************************/

/**
 * Bot Libre Open SDK.
 * تتيح لك مجموعة أدوات تطوير البرامج JavaScript هذه الوصول إلى خدمات روبوت الدردشة والدردشة المباشرة وغرفة الدردشة والمنتديات على
 * المواقع المتوافقة مع Bot Libre، بما في ذلك:
 * - بوت ليبري!
 * - بوت ليبري للأعمال
 * - الدردشة المباشرة مجانية!
 * - منتديات مجانية!
 *
 * يمكن استخدام نص JavaScript هذا مباشرةً، أو نسخه/تعديله على موقع الويب الخاص بك.
 *
 * تتكون مجموعة أدوات التطوير البرمجية (SDK) من فئتين رئيسيتين، SDKConnection وLiveChatConnection.
 *
 * يستخدم SDKConnection مكالمات AJAX لتوفير الوصول إلى واجهة برمجة تطبيقات REST المجانية.
 * يستخدم هذا لروبوتات الدردشة والمنتديات ومسؤولي المستخدمين والمجالات.
 *
 * يستخدم LiveChatConnection منافذ الويب لتوفير الوصول إلى الدردشة المباشرة وغرف الدردشة.
 *
 * الإصدار: 4.7.0-2016-09-16
 */

/**
 * فئة ثابتة لوظائف الاستخدام الشائعة والخصائص الثابتة.
 * @فصل
 */
var SDK = {};

SDK.DOMAIN = "www.botlibre.com";
SDK.NAME = "بوت مجاني!";
SDK.APP = "";

//SDK.DOMAIN = window.location.host;
//SDK.APP = "/botlibre";

SDK.PATH = "/rest/api";
SDK.MAX_FILE_UPLOAD = 5000000؛

SDK.host = SDK.DOMAIN؛
تطبيق SDK = SDK.APP؛
SDK.scheme = 'https:' == document.location.protocol ? "https" : "http";
SDK.url = SDK.scheme + "://" + SDK.DOMAIN + SDK.APP؛
SDK.rest = SDK.url + SDK.PATH؛
SDK.backlinkURL = SDK.url؛
SDK.backlink = صحيح؛

/**
 * يجب عليك تعيين معرف التطبيق الخاص بك لاستخدام SDK.
 * يمكنك الحصول على معرف التطبيق الخاص بك من صفحة المستخدم الخاصة بك.
 * @ثابت
 */
معرف تطبيق SDK = null؛

/**
 * تعيين رمز اللغة النشطة.
 * يستخدم هذا للتعرف على الصوت.
 */
SDK.lang = "ar";

/**
 * تمكين تسجيل التصحيح.
 * @ثابت
 */
SDK.debug = خطأ؛

/**
 * إجبار الصور الرمزية على استخدام القماش للفيديو (يستخدم حاليًا فقط لمتصفحي Chrome وFirefox).
 * @ثابت
 */
SDK.useCanvas = لا شيء؛

/**
 * محاولة إصلاح خلفية فيديو mp4 الرمادية (تستخدم فقط لمتصفح Chrome).
 * @ثابت
 */
SDK.fixBrightness = null؛

/**
 * تعيين حقل الخطأ الثابت لالتقاط أو تسجيل أي أخطاء.
 */
SDK.error = دالة (الرسالة) {
	console.log(الرسالة)؛
}

/**
 * السماح لواجهة برمجة تطبيقات الكلام الأصلي لدينا باستخدام واجهة برمجة تطبيقات ResponsiveVoice التابعة لجهة خارجية.
 * يجب عليك إنشاء حساب مع ResponsiveVoice لاستخدام واجهة برمجة التطبيقات الخاصة بهم، راجع https://responsivevoice.com
 * @ثابت
 */
SDK.responsiveVoice = خطأ؛
SDK.speechSynthesis = 'speechSynthesis' في النافذة؛
SDK.initResponsiveVoice = دالة () {
	إذا لم يكن ('responsiveVoice' في النافذة)) {
		console.log("ResponsiveVoice مفقود، يجب عليك تحميل البرنامج النصي الخاص به أولاً");
		يعود؛
	}
	SDK.responsiveVoice = صحيح؛
	SDK.speechSynthesis = صحيح؛
}
إذا (SpeechSynthesisUtterance == null) {
	دالة SpeechSynthesisUtterance(text) {
		هذا.النص = النص؛
	}
}

SDK.currentAudio = null؛
SDK.recognition = null؛
SDK.recognitionActive = خطأ؛
SDK.backgroundAudio = لا شيء؛
SDK.currentBackgroundAudio = null؛
SDK.timers = {};

/**
 * تشغيل ملف الصوت المعطى بالرابط.
 */
SDK.play = function(ملف، قناة الصوت) {
	SDK.pauseSpeechRecognition();
	var audio = new Audio(ملف)؛
	إذا (SDK.recognitionActive) {
		audio.addEventListener('انتهى', دالة() {
			SDK.startSpeechRecognition();
		}، خطأ شنيع)؛
	}
	إذا (القناة الصوتية == خطأ) {
		الصوت.تشغيل();
		عودة الصوت؛
	}
	إذا (SDK.currentAudio != null && !SDK.currentAudio.ended) {
		SDK.currentAudio.addEventListener('pause', function() {
			SDK.currentAudio = الصوت؛
			الصوت.تشغيل();
		}، خطأ شنيع)؛
		SDK.currentAudio.pause();
	} آخر {
		SDK.currentAudio = الصوت؛
		الصوت.تشغيل();
	}
	عودة الصوت؛
}

SDK.playChime = صحيح؛
/**
 * تشغيل صوت الجرس.
 */
SDK.chime = دالة () {
	إذا (SDK.playChime) {
		هذا.play(SDK.url + '/chime.wav');
		SDK.playChime = خطأ؛
		فار الموقت = setInterval(function () {
			SDK.playChime = صحيح؛
			clearInterval(المؤقت)؛
		}, 1000);
	}
}

/**
 * تحويل النص إلى كلام وتشغيله إما باستخدام دعم TTS الأصلي للمتصفح، أو كملف صوتي يتم إنشاؤه بواسطة الخادم.
 * الصوت اختياري ويمكن أن يكون أي صوت يدعمه الخادم (انظر صفحة الصوت للحصول على قائمة الأصوات).
 * بالنسبة للأصوات الأصلية، يمكن إعطاء رمز اللغة.
 * إذا كان المتصفح يدعم TTS، فسيتم استخدام الصوت الأصلي بشكل افتراضي.
 */
SDK.tts = دالة (نص، صوت، أصلي، لغة، صوت أصلي) {
	يحاول {
		إذا ((native || (native == null && voice == null)) && SDK.speechSynthesis) {
			varutterance = new SpeechSynthesisUtterance(text);
			SDK.nativeTTS(اللفظ، اللغة، الصوت الأصلي)؛
		} آخر {		
			var url = SDK.rest + '/form-speak?&text=';
			url = url + encodeURIComponent(النص)؛
			إذا (الصوت != null) {
				url = url + '&voice=' + صوت؛
			}
			إذا (معرف تطبيق SDK != null) {
				url = url + '&application=' + SDK.applicationId؛
			}
	
			var request = new XMLHttpRequest();
			var self = هذا؛
			طلب.onreadystatechange = دالة () {
				إذا (request.readyState != 4) ارجع؛
				إذا (حالة الطلب != 200) {
					console.log('خطأ: فشل طلب الويب الصوتي');
					يعود؛
				}
				self.play(SDK.url + "/" + request.responseText);
			}
			
			طلب.open('GET', url, true);
			طلب.إرسال();
		}
	} catch (خطأ) {
		console.log('خطأ: فشل طلب الويب الصوتي');
	}
}

/**
 * استخدم واجهة برمجة التطبيقات ResponsiveVoice.
 */
SDK.responsiveVoiceTTS = دالة (النطق، اللغة، الصوت) {
	أحداث var = {};
	يحاول {
		SDK.pauseSpeechRecognition();
		إذا (الصوت == لا شيء || الصوت == "") {
			الصوت = "الإنجليزية الأمريكية أنثى"؛
		}
		إذا (SDK.recognitionActive) {
			الأحداث.onend = دالة () {
				SDK.startSpeechRecognition();
			}
		}
		إذا (النهاية لا = لا شيء) {
			الأحداث.onend = utterance.onend؛
		}
		إذا (utterance.onstart != null) {
			الأحداث.onstart = utterance.onstart؛
		}
		responsiveVoice.speak(النطق. النص، الصوت، الأحداث)؛
	} catch (خطأ) {
		console.log(خطأ)؛
	}
}

/**
 * تحدث باللغة الأصلية أولاً مع ضبط الصوت واللغة.
 */
SDK.nativeTTS = دالة (النطق، اللغة، الصوت) {
	إذا (SDK.responsiveVoice) {
		SDK.responsiveVoiceTTS(اللفظ، اللغة، الصوت)؛
		يعود؛
	}
	إذا (lang == null) {
		اللغة = SDK.lang؛
	}
	SDK.pauseSpeechRecognition();
	إذا (SDK.recognitionActive) {
		utterance.addEventListener("النهاية"، دالة() {
			SDK.startSpeechRecognition();
		});
	}
	الكلام التوليفي.إلغاء();
	إذا (lang == null و voice == null) {
		// لا يتم إطلاق الأحداث دائمًا إلا إذا تم القيام بذلك ...
		تعيين الوقت(دالة() {
			speechSynthesis.speak(النطق)؛
		}, 100);
		يعود؛
	}
	var voices = speechSynthesis.getVoices();
	var foundVoice = null؛
	var foundLang = null؛
	var تحدث = خطأ؛
	إذا (طول الأصوات == 0) {
		الكلام المُلَحوظ.تغيير الأصوات = دالة () {
			إذا (تحدث) {
				يعود؛
			}
			الأصوات = speechSynthesis.getVoices();
	    	بالنسبة إلى (i = 0؛ i < طول الأصوات؛ i++) {
	    		إذا (الصوت != null و(طول الصوت != 0) وvoices[i].name.toLowerCase().indexOf(الصوت.toLowerCase()) != -1) {
	    			إذا (foundVoice == null || voices[i].name == voice) {
		    			foundVoice = الأصوات[i]؛	    				
	    			}
	    		} وإلا إذا (lang != null و(lang.length != 0) وvoices[i].lang.toLowerCase().indexOf(lang.toLowerCase()) != -1) {
	    			إذا (foundLang == null || voices[i].lang == lang) {
	    				foundLang = الأصوات[i]؛	    				
	    			}
	    		}
	    	}
	    	إذا (وجد الصوت != لا شيء) {
	    		utterance.voice = foundVoice؛
	    	} وإلا إذا (foundLang != null) {
	    		utterance.voice = foundLang؛	    		
	    	}
	    	تكلم = صحيح؛
			تعيين الوقت(دالة() {
				speechSynthesis.speak(النطق)؛
			},100);
	    };
	} آخر {
    	بالنسبة إلى (i = 0؛ i < طول الأصوات؛ i++) {
    		إذا (الصوت != null و(طول الصوت != 0) وvoices[i].name.toLowerCase().indexOf(الصوت.toLowerCase()) != -1) {
    			إذا (foundVoice == null || voices[i].name == voice) {
	    			foundVoice = الأصوات[i]؛	    				
    			}
    		} وإلا إذا (lang != null و(lang.length != 0) وvoices[i].lang.toLowerCase().indexOf(lang.toLowerCase()) != -1) {
    			إذا (foundLang == null || voices[i].lang == lang) {
    				foundLang = الأصوات[i]؛	    				
    			}
    		}
    	}
    	إذا (وجد الصوت != لا شيء) {
    		utterance.voice = foundVoice؛
    	} وإلا إذا (foundLang != null) {
    		utterance.voice = foundLang؛	    		
    	}
		تعيين الوقت(دالة() {
			speechSynthesis.speak(النطق)؛
		},100);
	}
}

/**
 * الكشف عن متصفح Chrome.
 */
SDK.isChrome = دالة () {
	العودة navigator.userAgent.toLowerCase().indexOf('chrome') > -1؛
}

/**
 * الكشف عن متصفح فايرفوكس.
 */
SDK.isFirefox = دالة () {
	العودة navigator.userAgent.toLowerCase().indexOf('firefox') > -1؛
}

/**
 * الكشف عن متصفح الهاتف المحمول.
 */
SDK.isMobile = دالة () {
	إذا (navigator.userAgent.match(/Android/i)
		 || navigator.userAgent.match(/webOS/i)
		 || navigator.userAgent.match(/iPhone/i)
		 || navigator.userAgent.match(/iPad/i)
		 || navigator.userAgent.match(/iPod/i)
		 || navigator.userAgent.match(/BlackBerry/i)
		 || navigator.userAgent.match(/Windows Phone/i)) {
		العودة صحيح؛
	} آخر {
		العودة كاذبة؛
	}
}

SDK.hd = خطأ؛
SDK.format = (SDK.isChrome() || SDK.isFirefox()) ? "webm" : "mp4";

/**
 * أدخل النص في حقل الإدخال.
 */
SDK.insertAtCaret = دالة (عنصر، نص) {
    إذا (اختيار المستند) {
        العنصر.التركيز();
        var sel = document.selection.createRange();
        sel.text = نص؛
        العنصر.التركيز();
    } وإلا إذا (element.selectionStart || element.selectionStart == 0) {
        var startPos = element.selectionStart;
        var endPos = element.selectionEnd;
        var scrollTop = element.scrollTop؛
        العنصر.القيمة = العنصر.القيمة.السلسلة الفرعية(0، موضع البدء) + النص + العنصر.القيمة.السلسلة الفرعية(موضع النهاية، طول العنصر.القيمة)؛
        العنصر.التركيز();
        العنصر.selectionStart = startPos + text.length؛
        العنصر.selectionEnd = startPos + text.length؛
        العنصر.scrollTop = scrollTop؛
    } آخر {
        العنصر.القيمة += النص؛
        العنصر.التركيز();
    }
}

/**
 * إصلاح innerHTML لمتصفحي IE وSafari.
 */
SDK.innerHTML = الوظيفة(العنصر) {
	var html = element.innerHTML؛
	إذا (html == null) {
		var serializer = new XMLSerializer();
		html = "";
		بالنسبة إلى (var index = 0؛ index < element.childNodes.length؛ index++) {
			html = html + serializer.serializeToString(element.childNodes[index]);
		}
	}
	var index = html.indexOf("<");
	var index2 = html.indexOf(">")
	إذا (المؤشر != -1 و المؤشر2 > المؤشر) {
		html = html.استبدال(/</g, "<");
		html = html.استبدال(/>/g, ">");
	}
	إذا (html.indexOf("&") != -1) {
		html = html.استبدال(/&/g، "&");
	}
	العودة html؛
}

/**
 * إزالة علامات HTML من النص.
 * إرجاع النص العادي.
 */
SDK.stripTags = دالة (html) {
	var element = document.createElement("p");
	العنصر.innerHTML = html؛
	العودة element.innerText || element.textContent؛
}

/**
 * استبدال أحرف HTML المحجوزة برموز الهروب HTML الخاصة بها.
 */
SDK.escapeHTML = دالة (html) {
	إرجاع html.replace(/&/g, "&")
    	.استبدال(/</g, "<")
    	.استبدال(/>/g, ">")
    	.استبدال(/"/g, """)
    	.استبدال(/'/g, "' ");
}

/**
 * استبدال عناوين URL والبريد الإلكتروني في النص بروابط HTML.
 */
SDK.linkURLs = دالة (نص) {
	var http = text.indexOf("http") != -1؛
	var www = text.indexOf("www.") != -1;
	var email = text.indexOf("@") != -1;
	إذا لم يكن (!http && !www && !email) {
		نص العودة؛
	}
	إذا (text.indexOf("<") != -1 && text.indexOf(">") != -1) {
		نص العودة؛
	}
	إذا (http) {
	    var regex = /\b(?:https?|ftp|file):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*[a- z0-9-+&@#\/%=~_|]/gim;
	    النص = text.replace(regex, function(url, b, c) {
	    	var lower = url.toLowerCase();
	    	إذا (lower.indexOf(".png") != -1 || lower.indexOf(".jpg") != -1 || lower.indexOf(".jpeg") != -1 || lower.indexOf(".gif") != -1) {
	    		العودة '<a href="' + url + '" target="_blank"><img src="' + url + '" height="50"></a>';
	    	} وإلا إذا (مؤشر الفهرس السفلي لـ(".mp4") != -1 || مؤشر الفهرس السفلي لـ(".webm") != -1 || مؤشر الفهرس السفلي لـ(".ogg") != -1) {
	    		العودة '<a href="' + url + '" target="_blank"><video src="' + url + '" height="50"></a>';
	    	} وإلا إذا (مؤشر أقل لـ(".wav") != -1 || مؤشر أقل لـ(".mp3") != -1) {
	    		العودة '<a href="' + url + '" target="_blank"><audio src="' + url + '" controls>الصوت</a>';
	    	} آخر {
	    		العودة '<a href="' + url + '" target="_blank">' + url + '</a>';
	    	}
	    });
	} وإلا إذا (www) {
	    var regex = /((www\.)[^\s]+)/gim;
	    النص = text.replace(regex, function(url, b, c) {
	        العودة '<a href="http://' + url + '" target="_blank">' + url + '</a>';
	    });
	}
    
    // http://، https://، ftp://
    //var urlPattern = /\b(?:https?|ftp):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*[a- z0-9-+&@#\/%=~_|]/gim;

    // www.
    // var wwwPattern = /(^|[^\/])(www\.[\S]+(\b|$))/gim;

    // الاسم@domain.com
	إذا (البريد الإلكتروني) {
    	var emailPattern = /(([a-zA-Z0-9_\-\.]+)@[a-zA-Z_]+?(?:\.[a-zA-Z]{2,6})) +/جيم;
    	النص = text.replace(emailPattern, '<a target="_blank" href="mailto:$1">$1</a>');
	}
	نص العودة؛
}

/**
 * تمكين التعرف على الكلام إذا كان المتصفح يدعمه، وإدخال الصوت إلى النص في حقل الإدخال.
 * اختياريا استدعاء click() على الزر.
 */
SDK.registerSpeechRecognition = دالة (الإدخال، الزر) {
	إذا (SDK.recognition == null) {
		إذا ('webkitSpeechRecognition' في النافذة) {
			SDK.recognition = new webkitSpeechRecognition();
			إذا (SDK.lang != null) {
				SDK.recognition.lang = SDK.lang؛
			}
			SDK.recognition.continuous = صحيح؛
			SDK.recognition.onresult = دالة (حدث) {
			    بالنسبة إلى (var i = event.resultIndex؛ i < event.results.length؛ ++i) {
			        إذا (نتائج الحدث[i].نهائية) {
			        	SDK.insertAtCaret(الإدخال، نتائج الحدث[i][0].transcript)؛	        	
			        }
			    }
			    إذا (الزر != null ونقرة الزر != null) {
			    	الزر. انقر();
				} وإلا إذا (الزر != null) {
					زر()؛
				}
			};
		} آخر {
			يعود؛
		}
	}
}

SDK.startSpeechRecognition = function() {
	إذا (SDK.recognition != null) {
		إذا (SDK.lang != null) {
			SDK.recognition.lang = SDK.lang؛
		}
		SDK.recognition.start();
		SDK.recognitionActive = صحيح؛
	}
}

SDK.pauseSpeechRecognition = function() {
	إذا (SDK.recognition != null) {
		SDK.recognition.stop();
	}
}

SDK.stopSpeechRecognition = function() {
	إذا (SDK.recognition != null) {
		SDK.recognition.stop();
		SDK.recognitionActive = خطأ؛
	}
}

SDK.popupwindow = function(url، العنوان، العرض، الارتفاع) {
	var left = (عرض الشاشة)-w-10؛
	var top = (ارتفاع الشاشة)-h-100؛
	window.open(url، العنوان، 'أشرطة التمرير=نعم، قابلة للتغيير=نعم، شريط الأدوات=لا، الموقع=لا، الدلائل=لا، الحالة=لا، شريط القوائم=لا، سجل النسخ=لا، العرض='+w+'، الارتفاع='+h+'، الأعلى='+أعلى+'، اليسار='+يسار)؛
	العودة كاذبة؛
}

SDK.dataURLToBlob = دالة (dataURL) {
    var mark = ';base64،';
    إذا (dataURL.indexOf(العلامة) == -1) {
        أجزاء فار = dataURL.split(',');
        var contentType = parts[0].split(':')[1];
        var raw = parts[1];

        إرجاع كائن جديد ([خام]، {نوع: نوع المحتوى});
    }

    أجزاء فار = dataURL.split(marker);
    var contentType = parts[0].split(':')[1];
    فار الخام = window.atob(parts[1]);
    var rawLength = raw.length؛

    var blobarray = new Uint8Array(rawLength);

    بالنسبة إلى (var i = 0؛ i < rawLength؛ ++i) {
    	blobarray[i] = raw.charCodeAt(i);
    }

    إرجاع كائن جديد ([blobarray]، {النوع: نوع المحتوى});
}

SDK.uploadImage = function(fileInput, url, width, height, properties, onFinish) {
	إذا (نافذة. ملف ونافذة. قارئ الملفات ونافذة. قائمة الملفات ونافذة. كائن) {
		ملفات var = fileInput.files؛
		بالنسبة إلى (var i = 0؛ i < طول الملفات؛ i++) {
			SDK.resizeAndUploadImage(files[i], url, width, height, properties, ((i == (files.length - 1) ? onFinish : null)))
		}
		العودة كاذبة؛
	} آخر {
		alert('لا يتم دعم واجهات برمجة التطبيقات للملفات بشكل كامل في هذا المتصفح.');
		العودة كاذبة؛
	}
}
			
SDK.resizeAndUploadImage = function(الملف، عنوان URL، العرض، الارتفاع، الخصائص، عند الانتهاء) {
	var Reader = new FileReader();
	reader.onloadend = دالة () {
		var tempImg = صورة جديدة();
		tempImg.src = reader.result؛
		tempImg.onload = دالة () {
			var MAX_WIDTH = العرض؛
			var MAX_HEIGHT = الارتفاع؛
			إذا (العرض == لا شيء) {
				الحد الأقصى للعرض = عرض الصورة المؤقتة؛
			}
			إذا (الارتفاع == لا شيء) {
				الحد الأقصى للارتفاع = ارتفاع درجة الحرارة؛
			}
			var tempW = tempImg.width؛
			var tempH = tempImg.height؛
			إذا (tempW > MAX_WIDTH) {
				 درجة الحرارةH *= الحد الأقصى للعرض / درجة الحرارةW؛
				 درجة الحرارةW = الحد الأقصى للعرض؛
			}
			إذا (درجة الحرارة > الحد الأقصى للارتفاع) {
				 درجة الحرارةW *= الحد الأقصى للارتفاع / درجة الحرارةH؛
				 درجة الحرارة = الحد الأقصى للارتفاع؛
			}
			var Canvas = document.createElement('canvas');
			عرض القماش = tempW؛
			قماش.الارتفاع = درجة الحرارة؛
			var ctx = canvas.getContext("2d");
			ctx.fillStyle = '#fff';
			ctx.fillRect(0، 0، عرض القماش، ارتفاع القماش)؛			
			ctx.drawImage(هذا، 0، 0، tempW، tempH)؛
            var dataUrl = Canvas.toDataURL('image/jpeg');
            var blob = SDK.dataURLToBlob(dataUrl);
			فار formData = new FormData();
			إذا (الخصائص != null) {
				بالنسبة إلى (الخاصية في الخصائص) {
					formData.append(الخاصية، الخصائص[الخاصية]);
				}
			}
			formData.append('ملف', blob, file.name);
			var request = new XMLHttpRequest();
			طلب.onreadystatechange = دالة () {
				إذا (طلب.readyState != 4) {
					يعود؛
				}
				إذا (onFinish != null) {
					على الانتهاء();
				}
			}
			طلب.open("POST", url);
			طلب.إرسال(بيانات النموذج)؛
		}
 
	 }
	 reader.readAsDataURL(ملف);
}

SDK.showError = دالة (الرسالة، العنوان) {
	إذا (العنوان == لا شيء) {
		العنوان = "خطأ";
	}
	$("<div></div>").html(الرسالة).حوار({
	    العنوان: العنوان،
	    قابلة للتغيير: خطأ،
	    نموذج: صحيح،
	    الأزرار: {
	        "حسنا": دالة () {
	            (هذا). الحوار("إغلاق");
	        }
	    }
	});
}

/**
 * مربع حوار تحميل الرسومات ومتصفح المستودع المشترك.
 * يوفر هذا مربع حوار تحميل الوسائط العامة مع العديد من الميزات:
 * <أول>
 * <li>واجهة مستخدم مربع الحوار "تحميل"
 * <li>تغيير حجم الصور محليًا قبل التحميل
 * <li>التحميل من عنوان URL على الويب
 * <li>تحميل ملف وسائط من مستودع رسومات مشترك
 * </ul>
 * @فصل
 */
دالة GraphicsUploader() {
	هذا.id = "متصفح الرسومات";
	this.title = "متصفح الوسائط";
	هذا.browserClass = "حوار";
	معرف الحوار هذا = "محمل الرسومات"؛
	this.dialogTitle = "تحميل الوسائط";
	هذا.dialogClass = "حوار";
	هذا.uploadURL = "upload-media";
	هذا.uploadFormProperties؛
	هذا.reloadOnSubmit = صحيح؛
	هذا.ملف الإدخال؛
	هذا.urlInput؛
	هذا.prefix = "uploader-";
	هذا.renderedDialog = false؛
	هذا.إرسال = صحيح؛
	هذا.showFile = صحيح؛
	هذا.showURL = صحيح؛
	هذا.showBrowse = صحيح؛
	هذا.sdk = لا شيء؛
	هذا الرابط؛	
	
	/**
	 * فتح مربع حوار تحميل JQyery.
	 */
	هذا.openUploadDialog = دالة () {
		إذا لم يتم عرض هذا الحوار
			هذا.renderUploadDialog();
		}
		( $( '#' + this.dialogId ).dialog("فتح");
	}
	
	/**
	 * فتح مربع حوار متصفح JQyery.
	 */
	هذا.openBrowser = دالة () {
		var browser = document.getElementById(this.id);
		إذا (المتصفح != null) {
			( $( '#' + هذا.id ).إزالة();
		}
		هذا.renderBrowser();
		( $( '#' + this.id ).dialog("فتح");
		هذا.fetchMedia();
	}

	/**
	 * عرض مربع حوار تحميل JQyery.
	 */
	هذا.renderUploadDialog = دالة () {
		var uploadDialog = document.createElement('div');
		uploadDialog.setAttribute('id', this.dialogId);
		uploadDialog.setAttribute('العنوان'، this.dialogTitle);
		uploadDialog.setAttribute('class', this.dialogClass);
		uploadDialog.style.display = "لا شيء";
		var html =
				"<style>\n"
				+ "." + this.prefix + "button { text-decoration:none; padding: 12px 2px 12px 2px; }\n"
				+ "." + this.prefix + "dialog-div { margin-top: 10px;margin-bottom: 10px; }\n"
				+ "</style>\n";
		إذا (هذا.عرض) {
			html = html
				+ "<div class='" + this.prefix + "dialog-div'>\n"
					+ "<a id='" + this.prefix + "browse-library' href='#' class='" + this.prefix + "button' title='تصفح مكتبة الوسائط المشتركة لدينا'>\n"
					+ "<img src='images/importr.png' style='vertical-align: middle'>\n"
					+ "تصفح مكتبة الوسائط"
					+ "</a>\n"
				+ "</div>\n";
		}
		إذا (هذا.عرض الملف) {
			إذا (هذا.عرض) {
				html = html + "<hr>\n";
			}
			html = html
				+ "<div class='" + this.prefix + "dialog-div'>\n"
					+ "<a id='" + this.prefix + "upload-media' href='#' class='" + this.prefix + "button' title='تحميل صورة أو ملف وسائط من جهاز الكمبيوتر أو الجهاز الخاص بك'>\n"
					+ "<img src='images/upload.png' style='vertical-align: middle'>\n"
					+ "تحميل من الكمبيوتر أو الجهاز</a>\n"
				+ "</div>\n"
				+ "<div class='" + this.prefix + "dialog-div'>\n"
					+ "<input id='" + this.prefix + "file-input' style='display:none' type='file' name='file' style='display:none'/>\n"
					+ "<input id='" + this.prefix + "resize' type='checkbox' title='تغيير حجم ملف الصورة محليًا إلى أقصى عرض للبكسل، لتقليل حجم الصور الكبيرة، وتوفير عرض النطاق الترددي للتحميل (استخدم فقط على ملفات الصور)'>\n"
					+ "تغيير الحجم إلى <input id='" + this.prefix + "resize-width' type='number' value='300' style='width:50px;height:25px' title='تغيير حجم الصورة بالبيكسل'> بيكسل\n"
				+ "</div>\n";
		}
		إذا (هذا.عرض عنوان URL) {
			إذا (هذا.عرض الملف || هذا.عرض التصفح) {
				html = html + "<hr>\n";
			}
			html = html
				+ "<div class='" + this.prefix + "dialog-div'>\n"
					+ "<a id='" + this.prefix + "upload-url' href='#' class='" + this.prefix + "button' title='استيراد صورة أو ملف وسائط من عنوان URL على الويب'>\n"
					+ "<img src='images/importr.png' style='vertical-align: middle'>\n"
					+ "استيراد من عنوان URL على الويب\n"
					+ "</a>\n"
				+ "</div>\n"
				+ "<input id='" + this.prefix + "url-input' type='text' style='width:100%'>\n";
		}
		uploadDialog.innerHTML = html;
		المستند.الجسم.appendChild(uploadDialog);
		
		var self = هذا؛
		var element = document.getElementById(this.prefix + "upload-media");
		إذا (العنصر != null) {
			عنصر.addEventListener("انقر"، دالة (حدث) {
				إذا (تم التحقق من المستند.getElementById(بادئة ذاتية + 'تغيير الحجم')) {
					document.getElementById(self.prefix + 'إدخال الملف').click();
				} آخر {
					self.fileInput.click();
				}
				العودة كاذبة؛			
			});
		}
		العنصر = document.getElementById(هذا.prefix + "إدخال الملف");
		إذا (العنصر != null) {
			عنصر.addEventListener("تغيير"، دالة(الحدث) {
				var width = parseInt(document.getElementById(self.prefix + 'resize-width').value);
				SDK.uploadImage(
						document.getElementById(self.prefix + 'إدخال الملف')،
						تحميل ذاتي URL،
						عرض،
						باطل،
						خصائص النموذج للتحميل الذاتي،
						وظيفة() {
							إذا (self.reloadOnSubmit) {
								الموقع.إعادة التحميل();
							}
						});
				العودة كاذبة؛
			});
		}
		العنصر = document.getElementById(هذا.prefix + "upload-url");
		إذا (العنصر != null) {
			عنصر.addEventListener("انقر"، دالة (حدث) {
				self.urlInput.value = document.getElementById(self.prefix + "url-input").value؛
				إذا (أرسلت ذاتيًا) {
					self.urlInput.form.submit();
				}
				العودة كاذبة؛			
			});
		}
		العنصر = document.getElementById(هذا.prefix + "استعراض المكتبة");
		إذا (العنصر != null) {
			عنصر.addEventListener("انقر"، دالة (حدث) {
				self.openBrowser(function(url) {
					إذا (url == null) {
						العودة كاذبة؛					
					}
					self.urlInput.value = url؛
					إذا (أرسلت ذاتيًا) {
						self.urlInput.form.submit();
					}
				});
				العودة كاذبة؛			
			});
		}
		
		( $( '#' + معرف الحوار هذا ).حوار({
			autoOpen: خطأ،
			نموذج: صحيح،
		    الأزرار: {
		        "إلغاء": دالة () {
		            (هذا). الحوار("إغلاق");
		        }
		    }
		});
		هذا.renderedDialog = صحيح؛
	}
	
	/**
	 * عرض مربع حوار متصفح JQyery.
	 */
	هذا.renderBrowser = دالة () {
		var browser = document.createElement('div');
		المتصفح.setAttribute('id', this.id);
		المتصفح.setAttribute('العنوان'، هذا.العنوان)؛
		المتصفح.setAttribute('class', this.browserClass);
		المتصفح.style.display = "لا شيء";

		var self = هذا؛
		GraphicsUploader.updateSearch = دالة () {
			self.fetchMedia();
		}
		var height = window.innerHeight - (window.innerHeight * 0.2);
		var width = window.innerWidth - (window.innerWidth * 0.2);
		var html =
				"<style>\n"
				+ "." + this.prefix + "button { text-decoration:none; padding: 12px 2px 12px 2px; }\n"
				+ "." + this.prefix + "browser-div { }\n"
				+ "." + this.prefix + "search-div { width:264px;margin:2px;display:inline-block;font-size:13px; }\n"
				+ "." + this.prefix + "search-span { display:inline-block;width:78px; }\n"
				+ "." + this.prefix + "browse-categories, ." + this.prefix + "browse-tags, , ." + this.prefix + "browse-filter { width:150px; }\n"
				+ "." + this.prefix + "browse-sort { width:150px; }\n"
				+ "." + this.prefix + "browse-div { display:inline-block;margin:2px;vertical-align:top; }\n"
				+ "." + this.prefix + "تفاصيل التصفح { حجم الخط: 12 بكسل؛ اللون: رمادي؛ }\n"
				+ "." + this.prefix + "browse-img { max-width:100px; max-height:100px; }\n"
				+ "." + this.prefix + "browse-span div { position:absolute;margin:-1px 0 0 0;padding:3px 3px 3px 3px;background:#fff;border-style:solid;border-color:black;border-width:1px;max-width:300px;min-width:100px;z-index:52;visibility:hidden;opacity:0;transition:visibility 0s linear 0.3s, opacity 0.3s linear; } \n"
				+ "." + this.prefix + "browse-span:hover div { display:inline;visibility:visible;opacity:1;transition-delay:0.5s; }\n"
				+ "</style>\n"
				+ "<div><div class='" + this.prefix + "search-div'><span class='" + this.prefix + "search-span'>الفئات</span><input id='" + this.prefix + "browse-categories' type='text'/></div>"
				+ " <div class='" + this.prefix + "search-div'><span class='" + this.prefix + "search-span'>العلامات</span><input id='" + this.prefix + "browse-tags' type='text'/></div>"
				+ " <div class='" + this.prefix + "search-div'><span class='" + this.prefix + "search-span'>فلتر</span><input id='" + this.prefix + "browse-filter' type='text'/></div>"
				+ " <div class='" + this.prefix + "search-div'><span class='" + this.prefix + "search-span'>فرز</span><select id='" + this.prefix + "browse-sort' onchange='GraphicsUploader.updateSearch()'><option value='name'>الاسم</option><option value='التاريخ'>التاريخ</option><option value='إبهام للأعلى'>إبهام للأعلى</option>\n"
				+ "<option value='thumbs down'>إبهام للأسفل</option><option value='نجوم'>نجوم</option><option value='ربط'>ربط</option></select>\n"
				+ "<a href='#' onclick='GraphicsUploader.updateSearch()' title='بحث'><img src='images/inspect.png' style='vertical-align: middle'></a></div>\n"
				+ "</div>\n"				
				+ "<div id='" + this.prefix + "browser-div' class='" + this.prefix + "browser-div'>\n"
				+ "</div>\n";
		المتصفح.innerHTML = html؛
		المستند.الجسم.appendChild(المتصفح);

		var self = هذا؛
		SDK.debug = صحيح؛
		إذا (هذا.sdk == null) {
			هذا.sdk = اتصال SDK جديد();
		}
		var autocompleteEvent = function(event) {
			var self = هذا؛
			(self).autocomplete('بحث', '');
		}
		إذا (GraphicsUploader.tags.length == 0) {
			var contentConfig = new ContentConfig();
			contentConfig.type = "رسومي";
			هذا.sdk.fetchTags(contentConfig، دالة(النتائج) {
				GraphicsUploader.tags = النتائج؛
				$( "#" + self.prefix + "browse-tags" ).autocomplete({ المصدر: GraphicsUploader.tags، الحد الأدنى للطول: 0، الإضافة إلى: $("#" + self.prefix + "browse-tags").parent() }).on('focus', autocompleteEvent);
			});
		} آخر {
			$( "#" + this.prefix + "browse-tags" ).autocomplete({ المصدر: GraphicsUploader.tags، الحد الأدنى للطول: 0، الإضافة إلى: $("#" + self.prefix + "browse-tags").parent() }).on('focus', autocompleteEvent);
		}
		إذا (GraphicsUploader.categories.length == 0) {
			var contentConfig = new ContentConfig();
			contentConfig.type = "رسومي";
			هذا.sdk.fetchCategories(contentConfig، دالة(النتائج) {
				GraphicsUploader.categories = النتائج؛
				$( "#" + self.prefix + "browse-categories" ).autocomplete({ المصدر: GraphicsUploader.categories، الحد الأدنى للطول: 0، الإضافة إلى: $("#" + self.prefix + "browse-categories").parent() }).on('focus', autocompleteEvent);
			});
		} آخر {
			$( "#" + this.prefix + "browse-categories" ).autocomplete({ المصدر: GraphicsUploader.categories، الحد الأدنى للطول: 0، الإضافة إلى: $("#" + self.prefix + "browse-categories").parent() }).on('focus', autocompleteEvent);
		}
		var keyPressed = دالة البحث (e) {
		    إذا (e.keyCode == 13) {
		    	self.fetchMedia();
		    }
		}
		$( "#" + this.prefix + "browse-tags" ).on("keydown", keyPressed);
		$( "#" + this.prefix + "استعراض الفئات" ).on("keydown", keyPressed);
		$( "#" + this.prefix + "browse-filter" ).on("keydown", keyPressed);
		
		( $( '#' + هذا.id ).dialog({
			autoOpen: خطأ،
			نموذج: صحيح،
            الارتفاع: الارتفاع،
            العرض: العرض،
		    الأزرار: {
		        "إلغاء": دالة () {
		            (هذا). الحوار("إغلاق");
		        }
		    }
		});
	}
	
	/**
	 * الاستعلام وعرض الرسومات.
	 */
	هذا.fetchMedia = دالة () {
		var browseConfig = new BrowseConfig();
		browseConfig.type = "رسومات";
		browseConfig.category = document.getElementById(this.prefix + 'browse-categories').value؛
		browseConfig.tag = document.getElementById(this.prefix + 'browse-tags').value؛
		browseConfig.filter = document.getElementById(هذا.prefix + 'browse-filter').value؛
		browseConfig.sort = document.getElementById(هذا.prefix + 'browse-sort').value؛
		var self = هذا؛
		var urlprefix = self.sdk.credentials.url + "/";
		GraphicsUploader.chooseMedia = function(id) {
			var config = new GraphicConfig();
			config.id = id؛
			self.sdk.fetch(config، دالة(النتيجة) {
				self.url = urlprefix + result.media؛
				إذا (self.urlInput != null) {
					self.urlInput.value = self.url؛
					إذا (أرسلت ذاتيًا) {
						self.urlInput.form.submit();
					}
				}
			});
		}
		هذا.sdk.browse(browseConfig، دالة (النتائج) {
			var div = document.getElementById(self.prefix + "browser-div");
			بينما (div.firstChild) {
				div.removeChild(div.الطفل الأول);
			}
			بالنسبة إلى (var index = 0؛ index < results.length؛ index++) {
				النتيجة = النتائج[الفهرس]؛
				var graphicDiv = document.createElement('div');
				graphicDiv.setAttribute('id', self.prefix + 'browse-div');
				graphicDiv.setAttribute('class', self.prefix + 'browse-div');
				var html =
					"<span id='" + self.prefix + "browse-span' class='" + self.prefix + "browse-span'>"
					+ "<table style='border-style:solid;border-color:grey;border-width:1px'><tr><td style='height:100px;width:100px;' align='center' valign='middle'>"
					+ "<a href='#' onclick='GraphicsUploader.chooseMedia(" + result.id + ")'><img id='" + self.prefix + "browse-img' class='" + self.prefix + "browse-img' src='" + urlprefix + result.avatar + "'></a>\n"
					+ "</td></tr></table>"
					+ "<div>"
					+ "<span><b>" + اسم النتيجة + "</b><br/>" + وصف النتيجة + "</span><br/>"
					+ "<span id='" + self.prefix + "browse-details' class='" + self.prefix + "browse-details'>";
				إذا (النتيجة.الفئات != null و النتيجة.الفئات != "") {
					html = html + "الفئات: " + النتيجة.الفئات + "<br/>";
				}
				إذا (result.tags != null && result.tags != "") {
					html = html + "العلامات: " + النتيجة.العلامات + "<br/>";
				}
				إذا (نتيجة الترخيص != null و نتيجة الترخيص != "") {
					html = html + "الترخيص: " + النتيجة.الترخيص + "<br/>";
				}
				html = html
					+ "</div>"
					+ "</span>\n"
					+ "<div style='max-width:100px'><a href='#' style='text-decoration:none;' onclick='GraphicsUploader.chooseMedia(" + result.id + ")'><span id='" + self.prefix + "browse-details' class='" + self.prefix + "browse-details'>" + result.name + "</span></div></a>\n";
				graphicDiv.innerHTML = html؛
				var img = document.createElement('img');
				img.setAttribute('src', urlprefix + result.avatar);
				div.appendChild(graphicDiv);
			}
		});
	}
}

GraphicsUploader.map = {};

GraphicsUploader.tags = [];
GraphicsUploader.categories = [];

/**
 * افتح مربع حوار تحميل الوسائط الذي تم تهيئته باستخدام نموذج.
 * سوف يستخدم الحوار إجراء النموذج لتحميل الوسائط كـ "ملف" لملف، أو "upload-url" لعنوان URL.
 * يجب أن يحدد النموذج معرفًا إذا كان سيتم استخدامه في نماذج متعددة في نفس المستند.
 * يمكن استخدام هذا عند النقر على عنصر الإدخال لفتح مربع الحوار، على سبيل المثال <input type="submit" onclick="return GraphicsUploader.openUploadDialog(this.form)" value="Upload">
 * سيؤدي هذا إلى إنشاء إدخال مخفي من نوع الملف ('ملف')، وإدخال مخفي من نوع النص ('upload-url')، وسيتم تمريرها إلى الخادم الخاص بك عندما يرسل الحوار النموذج.
 */
GraphicsUploader.openUploadDialog = function(النموذج، العنوان، عرض الملف، عرض عنوان URL، عرض التصفح) {    	
	متغير id = form.getAttribute('id');
	var prefix = "uploader-";
	var DialogueId = "graphics-uploader";
	var browserId = "متصفح الرسومات";
	إذا (id == null) {
		المعرف = "الرافع"؛
	} آخر {
		البادئة = معرف + '-' + البادئة؛
		DialogId = id + '-' + DialogId;
		browserId = id + '-' + browserId;
	}
	var uploader = GraphicsUploader.map[id];
	إذا (المحمل == null) {
		المحمل = محمل الرسومات الجديد();
		GraphicsUploader.map[id] = المحمل؛
		var div = document.createElement('div');
		var html =
			"<input id='" + id + "file-input' style='display:none' onchange='this.form.submit()' type='file' name='file'/>\n"
			+ "<input id='" + id + "url-input' style='display:none' name='upload-url' type='text'>";
		div.innerHTML = html؛
		النموذج.appendChild(div);
		إذا (العنوان != null) {
			uploader.dialogTitle = العنوان؛
		}
		إذا (عرض الملف != null) {
			المرفوع.showFile = showFile؛
		}
		إذا (showURL != null) {
			المحمل.showURL = showURL؛
		}
		إذا (إظهار التصفح != null) {
			المرفوع.showBrowse = showBrowse؛
		}
		uploader.prefix = البادئة؛
		المحمل.dialogId = معرف الحوار؛
		المحمل.id=معرف المتصفح؛
		المحمل.fileInput = document.getElementById(id + 'إدخال الملف');
		المحمل.urlInput = document.getElementById(id + 'url-input');
		المحمل.uploadURL = نموذج.action؛
	}
	المحمل.openUploadDialog();
	العودة كاذبة؛
}

/**
 * بيانات الاعتماد المستخدمة لإنشاء اتصال.
 * يحدد عنوان URL والمضيف والتطبيق والباقي، والتي يتم تعيينها جميعًا افتراضيًا ولا ينبغي أن تكون هناك حاجة إلى تغييرها،
 * يتطلب معرف التطبيق.
 * يمكنك الحصول على معرف التطبيق الخاص بك من صفحة تفاصيل المستخدم الخاصة بك على موقع الاستضافة.
 * @فصل
 */
وظيفة بيانات الاعتماد () {
	هذا.host = SDK.host؛
	هذا التطبيق = SDK.app؛
	هذا.url = SDK.url؛
	هذا.rest = SDK.rest؛
	هذا.معرف التطبيق = SDK.معرف التطبيق؛
}

/**
 * بيانات اعتماد الاستخدام مع الخدمات المستضافة على موقع BOT libre، وهي خدمة استضافة بوت مجانية.
 * http://www.botlibre.com
 * @فصل
 */
وظيفة BOTlibreCredentials() {
	هذا.DOMAIN = "www.botlibre.com";
	هذا.التطبيق = "";
	هذا.PATH = "/rest/botlibre";
	
	هذا.المضيف = هذا.المجال؛
	هذا.التطبيق = هذا.التطبيق؛
	هذا.url = "http://" + هذا.DOMAIN + هذا.APP؛
	هذا.rest = هذا.url + هذا.PATH؛
	هذا.معرف التطبيق = SDK.معرف التطبيق؛
}

/**
 * بيانات الاعتماد للاستخدام مع الخدمات المستضافة على موقع Paphus Live Chat،
 * خدمة استضافة الدردشة الحية التجارية، وغرفة الدردشة، والمنتدى، وبرنامج الدردشة الآلي.
 * http://www.paphuslivechat.com
 * @فصل
 */
دالة PaphusCredentials() {
	هذا.DOMAIN = "www.paphuslivechat.com";
	هذا.التطبيق = "";
	هذا.PATH = "/rest/livechat";
	
	هذا.المضيف = هذا.المجال؛
	هذا.التطبيق = هذا.التطبيق؛
	هذا.url = "http://" + هذا.DOMAIN + هذا.APP؛
	هذا.rest = هذا.url + هذا.PATH؛
	هذا.معرف التطبيق = SDK.معرف التطبيق؛
}

/**
 * بيانات اعتماد للاستخدام مع الخدمات المستضافة على موقع LIVE CHAT libre، والدردشة الحية المجانية، وغرف الدردشة، والمنتديات، وبوتات الدردشة التي تتعلم.
 * http://www.livechatlibre.com
 * @فصل
 */
وظيفة LIVECHATlibreCredentials() {
	هذا.DOMAIN = "www.livechatlibre.com";
	هذا.التطبيق = "";
	هذا.PATH = "/rest/livechatlibre";
	
	هذا.المضيف = هذا.المجال؛
	هذا.التطبيق = هذا.التطبيق؛
	هذا.url = "http://" + هذا.DOMAIN + هذا.APP؛
	هذا.rest = هذا.url + هذا.PATH؛
	هذا.معرف التطبيق = SDK.معرف التطبيق؛
}

/**
 * بيانات اعتماد الاستخدام مع الخدمات المستضافة على موقع FORUMS libre، وهي خدمة استضافة منتديات مجانية قابلة للتضمين.
 * http://www.forumslibre.com
 * @فصل
 */
وظيفة FORUMSlibreCredentials() {
	هذا.DOMAIN = "www.forumslibre.com";
	هذا.التطبيق = "";
	هذا.PATH = "/rest/forumslibre";
	
	هذا.المضيف = هذا.المجال؛
	هذا.التطبيق = هذا.التطبيق؛
	هذا.url = "http://" + هذا.DOMAIN + هذا.APP؛
	هذا.rest = هذا.url + هذا.PATH؛
	هذا.معرف التطبيق = SDK.معرف التطبيق؛
}

/**
 * واجهة المستمع لـ LiveChatConnection.
 * يؤدي هذا إلى إرسال إشعار غير متزامن عندما تتلقى قناة رسالة أو إشعارًا.
 * @فصل
 */
وظيفة LiveChatListener() {
	/**
	 * تم استلام رسالة مستخدم من القناة.
	 */
	هذه الرسالة = دالة (الرسالة) {}؛
	
	/**
	 *تم استلام رسالة إعلامية من القناة.
	 * مثل انضمام مستخدم جديد، أو طلب خاص، وما إلى ذلك.
	 */	
	هذه.info = دالة(الرسالة) {};

	/**
	 * تم استلام رسالة خطأ من القناة.
	 * قد يكون هذا خطأ في الوصول، أو فشل في الرسالة.
	 */	
	هذا.الخطأ = دالة(الرسالة) {};
	
	/**
	 * إشعار بأن الاتصال تم إغلاقه.
	 */
	هذا.مغلق = دالة () {}؛
	
	/**
	 * القنوات التي قام المستخدمون بتغييرها (انضم المستخدم، غادر، إلخ.)
	 * يحتوي هذا على قائمة قيم مفصولة بفاصلة (CSV) لمستخدمي القناة الحاليين.
	 * يمكن تمريره إلى واجهة برمجة التطبيقات SDKConnection.getUsers() للحصول على معلومات UserConfig للمستخدمين.
	 */
	هذا.تحديث المستخدمين = دالة (المستخدمين CSV) {}؛

	/**
	 * القنوات التي قام المستخدمون بتغييرها (انضم المستخدم، غادر، إلخ.)
	 * يحتوي هذا على قائمة HTML لمستخدمي القناة الحاليين.
	 * يمكن إدراجه في مستند HTML لعرض المستخدمين.
	 */
	هذا.updateUsersXML = function(usersXML) {};
}

/**
 * يوفر WebLiveChatListener تكاملاً بين LiveChatConnection ومستند HTML.
 * يقوم بتحديث المستند إلى الرسالة المستلمة من الاتصال، ويرسل الرسائل من نموذج المستند.
 * تتطلب وثيقة HTML العناصر التالية:
 * - دردشة - <input type='text'> إدخال نص الدردشة لإرسال الرسائل
 * - إرسال - زر <input type='submit'> لإرسال إدخال الدردشة
 * - الرد - فقرة <p> لرسالة الدردشة الأخيرة
 * - وحدة التحكم - <table> جدول لسجل الدردشة وسجل المستخدم
 * - scroller - <div> div لجزء تمرير سجل الدردشة
 * - متصل بالإنترنت - <table> جدول لقائمة مستخدمي الدردشة
 * @فصل
 */
وظيفة WebLiveChatListener() {
	/** تعيين التسمية التوضيحية لزر شريط الأزرار. */
	هذا.caption = لا شيء؛
	هذا.switchText = صحيح؛
	هذا.playChime = صحيح؛
	هذا الكلام = خطأ؛
	هذا.الصوت = لا شيء؛
	هذا.nativeVoice = null؛
	هذا.nativeVoiceName = null؛
	هذه.اللغة = لا شيء؛
	هذا.nick = "";
	هذا.الاتصال = لا شيء؛
	هذا.sdk = لا شيء؛
	/** قم بتكوين ما إذا كان يجب التركيز على الدردشة بعد الرسالة. */
	هذا.التركيز = صحيح؛
	/** معرف العنصر وبادئة الفئة. يمكن استخدامهما للحصول على صور رمزية متعددة في نفس الصفحة، أو لتجنب تضارب الأسماء. */
	هذا.البادئة = "";
	/** السماح بتعيين لون زر مربع الدردشة. */
	هذا.اللون = "#009900";
	/** السماح بتعيين لون زر التحويم في مربع الدردشة. */
	هذا.hoverColor = "رمادي";
	/** السماح بتعيين لون خلفية مربع الدردشة. */
	هذه الخلفية = لا شيء؛
	/** عرض مربع الدردشة. */
	هذا العرض = 300؛
	/** ارتفاع مربع الدردشة. */
	هذا.الارتفاع = 320؛
	/** صندوق الدردشة من الجانب. */
	هذا.الإزاحة = 30؛
	/** طباعة الرد في فقاعة الدردشة. */
	هذه الفقاعة = خطأ؛
	/** قم بتعيين موقع الزر والمربع، أحدها "أسفل اليمين"، "أسفل اليسار"، "أعلى اليمين"، "أعلى اليسار". */
	هذا.boxLocation = "أسفل اليمين";
	/** قم بتعيين الأنماط صراحةً لتجنب وراثة أنماط الصفحة. قم بتعطيل هذا لتتمكن من تجاوز الأنماط. */
	هذا.forceStyles = صحيح؛
	/** تجاوز عنوان URL المستخدم في النافذة المنبثقة لمربع الدردشة. */
	هذا.popupURL = null؛
	/** حدد ما إذا كان يجب عرض سجل الدردشة في المربع. */
	هذا. سجل الدردشة = صحيح؛
	/** رسالة تحميل الدردشة في المربع لعرضها. */
	هذا.loading = "جاري التحميل...";
	/** خيار غرفة الدردشة في الصندوق. */
	هذه غرفة الدردشة = خطأ؛
	/** خيار عرض المستخدمين المتصلين عبر الدردشة في الصندوق. */
	هذا.online = خطأ؛
	/** رابط لقائمة المستخدمين المتصلين بالإنترنت لصفحة ملفهم الشخصي. */
	هذا.linkUsers = صحيح؛
	/** تكوين تنسيق سجل الرسائل (جدول أو سجل). */
	هذا.chatLogType = "سجل";
	/** المطالبة بالاسم/البريد الإلكتروني قبل الاتصال. */
	هذا.promptContactInfo = false؛
	هذا.hasContactInfo = false؛
	هذا.اسم جهة الاتصال = لا شيء؛
	هذا.contactEmail = null؛
	هذا.هاتف الاتصال = لا شيء؛
	هذا.معلومات الاتصال = "";
	
	هذا.عنوان النافذة = عنوان المستند؛
	هذا.نشط = صحيح؛
	
	الذات = هذا؛
	
	/**
	 * إنشاء شريط تضمين و div في صفحة الويب الحالية.
	 */
	هذا.createBox = دالة () {
		إذا (هذا.prefix == "" و هذا.elementPrefix != null) {
			هذا.البادئة = هذا.العنصرالبادئة؛
		}
		إذا (هذا العنوان == لا شيء) {
			هذا.caption = هذا.instanceName؛
		}
		var backgroundstyle = "";
		var buttonstyle = "";
		var buttonHoverStyle = "";
		var hidden = "مخفي";
		var border = "";
		إذا (هذه الخلفية إذا لم تكن كروم وSDK.isChrome()) {
			هذه الخلفية = لا شيء؛
		}
		إذا (هذه الخلفية != null) {
			نمط الخلفية = "style='لون الخلفية:" + هذه.الخلفية + "'";
			مخفي = "مرئي"؛
			الحدود = "الحدود: 1 بكسل؛ نمط الحدود: صلب؛ لون الحدود: أسود؛";
		}
		إذا (هذا اللون لا يساوي null) {
			buttonstyle = "لون الخلفية:" + هذا.اللون + ";";
		}
		إذا (هذا.hoverColor != null) {
			buttonHoverStyle = "لون الخلفية:" + this.hoverColor + ";";
		}
		var minWidth = "";
		var divWidth = "";
		var background = "";
		var minHeight = "";
		var divHeight = "";
		إذا (هذا العرض != null) {
			الحد الأدنى للعرض = "العرض:" + هذا العرض + "بكسل؛"؛
			الخلفية = "حجم الخلفية:" + هذا العرض + "بيكسل تلقائي؛"؛
			عرض القسم = الحد الأدنى للعرض؛
			divHeight = "الحد الأدنى للارتفاع:" + هذا العرض + "بكسل؛";
			responseWidth = "العرض:" + (هذا العرض - 16) + "بكسل؛";
		}
		إذا (هذا الارتفاع != null) {
			الحد الأدنى للارتفاع = "الارتفاع:" + هذا الارتفاع + "بكسل؛"؛
			ارتفاع القسم = الحد الأدنى للارتفاع؛
			إذا (هذا العرض != null) {
				الخلفية = "حجم الخلفية:" + هذا. العرض + "بكسل" + هذا. الارتفاع + "بكسل؛"؛
			} آخر {
				الخلفية = "حجم الخلفية: تلقائي" + هذا.الارتفاع + "بكسل؛"؛
				divWidth = "الحد الأدنى للعرض:" + هذا.height + "px;";
			}
		}
		var boxloc = "القاع: 10 بكسل؛ اليمين: 10 بكسل"؛
        إذا (هذا.boxLocation == "أعلى اليسار") {
            boxloc = "أعلى: 10 بكسل؛ اليسار: 10 بكسل"؛
        } وإلا إذا (هذا.boxLocation == "أعلى اليمين") {
            boxloc = "أعلى: 10 بكسل؛ يمين: 10 بكسل"؛
        } وإلا إذا (هذا.boxLocation == "bottom-left") {
            boxloc = "الأسفل: 10 بكسل؛ اليسار: 10 بكسل"؛
        } وإلا إذا (هذا.boxLocation == "أسفل اليمين") {
            boxloc = "الأسفل: 10 بكسل؛ اليمين: 10 بكسل"؛
        }
        var boxbarloc = "bottom:2px;right:" + this.offset + "px";
        إذا (هذا.boxLocation == "أعلى اليسار") {
            boxbarloc = "top:2px;left:" + this.offset + "px";
        } وإلا إذا (هذا.boxLocation == "أعلى اليمين") {
            boxbarloc = "top:2px;right:" + this.offset + "px";
        } وإلا إذا (هذا.boxLocation == "bottom-left") {
            boxbarloc = "القاع: 2 بكسل؛ اليسار:" + هذا. الإزاحة + "بكسل"؛
        } وإلا إذا (هذا.boxLocation == "أسفل اليمين") {
            boxbarloc = "القاع: 2 بكسل؛ اليمين:" + هذا. الإزاحة + "بكسل"؛
        }
		var box = document.createElement('div');
		var html =
			"<style>\n"
				+ "." + this.prefix + "box { position:fixed;" + boxloc + ";z-index:52;margin:2px;display:none;" + border + " }\n"
				+ "." + this.prefix + "box:hover { border:1px;border-style:solid;border-color:black; }\n"
				+ "." + this.prefix + "boxmenu { visibility:" + hidden + "; margin-bottom:12px; }\n"
				+ "." + this.prefix + "box:hover ." + this.prefix + "boxmenu { visibility:visible; }\n"
				+ "." + this.prefix + "boxclose, ." + this.prefix + "boxmin, ." + this.prefix + "boxmax { حجم الخط: 22 بكسل؛ الهامش: 2 بكسل؛ الحشو: 0 بكسل؛ زخرفة النص: لا شيء؛ }\n"
				+ (this.forceStyles ? "#" : ".") + "" + this.prefix + "boxbarmax { حجم الخط: 18 بكسل؛ الهامش: 2 بكسل؛ الحشو: 0 بكسل؛ زخرفة النص: لا شيء؛ اللون: أبيض؛ }\n"
				+ "." + this.prefix + "boxclose:hover, ." + this.prefix + "boxmin:hover, ." + this.prefix + "boxmax:hover { color: #fff;background: grey; }\n"
				+ "." + this.prefix + "boxbar { position:fixed;" + boxbarloc + ";z-index:52;margin:0;padding:6px;" + buttonstyle + " }\n"
				+ "." + this.prefix + "boxbar:hover { " + buttonHoverStyle + " }\n"
				+ "#" + this.prefix + "معلومات الاتصال { " + minHeight + minWidth + " }\n"
				+ "#" + this.prefix + "معلومات الاتصال span { margin-left:4px;margin-top:4px; }\n"
				+ "#" + this.prefix + "معلومات الاتصال المدخلة { الهامش: 4 بكسل؛ حجم الخط: 13 بكسل؛ الارتفاع: 33 بكسل؛ العرض: 90٪؛ الحد: 1 بكسل ثابت # d5d5d5؛ }\n"
				+ "." + this.prefix + "contactconnect { margin:4px;padding:8px;color:white;text-decoration:none;" + buttonstyle + " }\n"
				+ "." + this.prefix + "no-bubble { margin:4px; padding:8px; border:1px; border-style:solid; border-color:black; background-color:white; }\n"
				+ "." + this.prefix + "no-bubble-plain { margin:4px; padding:8px; border:1px; }\n"
				+ "." + this.prefix + "no-bubble-text { " + responseWidth + "; max-height:100px; overflow:auto; }\n"
				+ "." + this.prefix + "boxbutton { عرض: 20 بكسل؛ ارتفاع: 20 بكسل؛ هامش 2 بكسل؛ }\n"
				+ "." + this.prefix + "bubble-div { padding-bottom:15px;position:relative; }\n"
				+ "." + this.prefix + "bubble { margin:4px; padding:8px; border:1px; border-style:solid; border-color:black; border-radius:10px; background-color:white; }\n"
				+ "." + this.prefix + "bubble-text { " + responseWidth + "; max-height:100px; overflow:auto; }\n"
				+ "." + this.prefix + "bubble:before { content:''; position:absolute; bottom:0px; left:40px; border-width:20px 0 0 20px; border-style:solid; border-color:black transparent; display:block; width:0;}\n"
				+ "." + this.prefix + "bubble:after { content:''; position:absolute; bottom:3px; left:42px; border-width:18px 0 0 16px; border-style:solid; border-color:white transparent; display:block; width:0;}\n"
				+ (this.forceStyles ? "#" : ".") + this.prefix + "chat { width:100%;min-height:22px; }\n"
				+ "." + this.prefix + "box-input-span { عرض: كتلة؛ تجاوز: مخفي؛ هامش: 4 بكسل؛ حشوة-يمين: 4 بكسل؛ }\n"
				+ "." + this.prefix + "scroller { overflow:auto;" + minHeight + minWidth + " }\n"
				+ "a." + this.prefix + "menuitem { text-decoration: none;display: block;color: #585858; }\n"
				+ "a." + this.prefix + "menuitem:hover { color: #fff;background: grey; }\n"
				+ "tr." + this.prefix + "menuitem:hover { الخلفية: رمادية؛ }\n"
				+ "img." + this.prefix + "menu { width: 24px;height: 24px;margin: 2px;cursor: pointer;vertical-align: middle; }\n"
				+ "span." + this.prefix + "menu { color: #818181;font-size: 12px; }\n"
				+ "img." + this.prefix + "شريط الأدوات { العرض: 32 بكسل؛ الارتفاع: 32 بكسل؛ الهامش: 1 بكسل؛ الحشو: 1 بكسل؛ المؤشر: المؤشر؛ المحاذاة الرأسية: الأوسط؛ نمط الحد: صلب؛ عرض الحد: 1 بكسل؛ لون الحد: #fff؛ }\n"
				+ "td." + this.prefix + "شريط الأدوات { العرض: 36 بكسل؛ الارتفاع: 36 بكسل }\n"
				+ "." + this.prefix + "menupopup div { position:absolute;margin: -1px 0 0 0;padding: 3px 3px 3px 3px;background: #fff;border-style:solid;border-color:black;border-width:1px;width:160px;max-width:300px;z-index:52;visibility:hidden;opacity:0;transition:visibility 0s linear 0.3s, opacity 0.3s linear; }\n"
				+ "." + this.prefix + "menupopup:hover div { display:inline;visibility:visible;opacity:1;transition-delay:0.5s; }\n"
				+ ".online-user { border-style: solid;border-color: grey;border-width: 1px;margin: 2px;padding: 2px;display: inline-block; }\n"
				+ ".online-user-label { اللون: #818181; حجم الخط: 12 بكسل; الهامش: 2 بكسل; الحد الأقصى للعرض: 200 بكسل; الفائض: مخفي; }\n"
				+ "img.chat-user-thumb { الارتفاع: 50 بكسل؛ }\n"
				+ "a.user { زخرفة النص: لا شيء؛ }\n"
				+ "td." + this.prefix + "chat-1 { width:100%;background-color: #d5d5d5;}\n"
				+ "span." + this.prefix + "chat-1 { color:#333;}"
				+ "span." + this.prefix + "chat-user { color:grey;font-size:small; }"
				+ this.prefix + "console { width:100%; }"
				+ "#" + this.prefix + "boxtable { الخلفية: لا شيء؛ الحدود: لا شيء؛ الهامش: 0؛ }\n"
			+ "</style>\n"
			+ "<div id='" + this.prefix + "box' class='" + this.prefix + "box' " + backgroundstyle + ">"
				+ "<div class='" + this.prefix + "boxmenu'>"
					+ "<span style='float:right'><a id='" + this.prefix + "boxmin' class='" + this.prefix + "boxmin' href='#'><img src='" + SDK.url + "/images/minimize.png'></a> <a id='"
					+ this.prefix + "boxmax' class='" + this.prefix + "boxmax' href='#'><img src='" + SDK.url + "/images/open.png'></a></span><br/>"
				+ "</div>";
		
		إذا (هذا.متصل) {
			html = html
        		+ "<div id='" + this.prefix + "online-div' class='" + this.prefix + "online-div'>"
        			+ "<div id='" + this.prefix + "online' class='" + this.prefix + "online'>"
        				+ "<table></table>"
        			+ "</div>"
        		+ "</div>";
		}
		إذا (هذا سجل الدردشة) {
			html = html
        		+ "<div id='" + this.prefix + "scroller' class='" + this.prefix + "scroller'>"
        		+ "<table id='" + this.prefix + "console' class='" + this.prefix + "console' cellspacing=2></table>"
        		+ "</div>"
		}
		var urlprefix = this.sdk.credentials.url + "/";
		html = html
				+ "<div>\n"
					+ "<div " + (هذه الفقاعة؟ "class='" + هذه الفقاعة + "bubble-div'" : "") + ">"
					+ "<div class='" + this.prefix + "" + (this.bubble ? "bubble" : (this.background == null ? "no-bubble" : "no-bubble-plain") )
					+ "'><div class='" + this.prefix + (this.bubble ? "bubble-text" : "no-bubble-text" ) + "'>"
						+ "<span id='" + this.prefix + "response'>" + this.loading + "</span><br/>"
					+ "</div></div></div>\n";
		html = html
			+ "<table id='" + this.prefix + "boxtable' class='" + this.prefix + "boxtable' style='width:100%'><tr>\n"
			+ "<td class='" + this.prefix + "toolbar'><span class='" + this.prefix + "menu'>\n"
			+ "<div style='inline-block;position:relative'>\n"
			+ "<span class='" + this.prefix + "menupopup'>\n"
			+ "<div style='text-align:left;bottom:36px'>\n"
			+ "<الجدول>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
			+ "<td><a id='" + this.prefix + "ping' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/empty.png' title='التحقق من اتصالك بالخادم'> خادم Ping</a></td>"
			+ "</tr>\n";
    	إذا (هذه غرفة الدردشة) {
		    html = html
        		+ "<tr class='" + this.prefix + "menuitem'>"
        			+ "<td><a id='" + this.prefix + "flag' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/flag2.png' title='إبلاغ المستخدم عن المحتوى المسيء'> إبلاغ المستخدم</a></td>"
        		+ "</tr>\n"
        		+ "<tr class='" + this.prefix + "menuitem'>"
        			+ "<td><a id='" + this.prefix + "whisper' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/whisper.png' title='إرسال رسالة خاصة إلى مستخدم آخر'> مستخدم Whisper</a></td>"
        		+ "</tr>\n"
        		+ "<tr class='" + this.prefix + "menuitem'>"
        			+ "<td><a id='" + this.prefix + "pvt' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/accept.png' title='دعوة مستخدم آخر إلى قناة خاصة'> طلب خاص</a></td>"
        		+ "</tr>\n"
    	}
		html = html
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "clear' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/empty.png' title='مسح سجل الدردشة المحلي'> مسح السجل</a></td>"
			+ "</tr>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "accept' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/accept.png' title='قبول طلب خاص من مشغل أو روبوت أو مستخدم آخر'> قبول خاص</a></td>"
			+ "</tr>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "sendImage' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/image.png' title='تغيير حجم الصورة وإرسالها كمرفق'>إرسال الصورة</a></td>"
			+ "</tr>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "sendAttachment' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/attach.png' title='إرسال صورة أو ملف مرفق'> إرسال ملف</a></td>"
			+ "</tr>\n";
		html = html
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "toggleChime' class='" + this.prefix + "menuitem' href='#'><img id='boxchime' class='" + this.prefix + "menu' src='" + SDK.url + "/images/sound.png' title='تشغيل رنين عند استلام رسالة'> رنين</a></td>"
			+ "</tr>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "toggleSpeak' class='" + this.prefix + "menuitem' href='#'><img id='boxtalk' class='" + this.prefix + "menu' src='" + SDK.url + "/images/talkoff.png' title='تحدث بكل رسالة باستخدام التوليف الصوتي'> تحويل النص إلى كلام</a></td>"
			+ "</tr>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "toggleListen' class='" + this.prefix + "menuitem' href='#'>"
						+ "<img id='boxmic' class='" + this.prefix + "menu' src='" + SDK.url + "/images/micoff.png' title='تمكين التعرف على الكلام (يجب أن يدعم المتصفح التعرف على الكلام HTML5، مثل Chrome)'> التعرف على الكلام</a>"
				+ "</td>"
			+ "</tr>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a id='" + this.prefix + "exit' class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + SDK.url + "/images/quit.png' title='الخروج من القناة أو القناة الخاصة النشطة'> الخروج من القناة الخاصة أو القناة</a></td>"
			+ "</tr>\n"
			+ "</table>\n"
			+ "</div>\n"
			+ "<img class='" + this.prefix + "toolbar' src='" + SDK.url + "/images/menu.png'>\n"
			+ "</span>\n"
			+ "</div>\n"
    		+ "</span></td>\n";
		
		html = html
			+ "<td><span class='" + this.prefix + "box-input-span'><input id='" + this.prefix + "chat' type='text' class='" + this.prefix + "box-input'/></span></td>"
			+ "</tr></table>"
			+ "</div>\n"
			+ "</div>\n"
			+ "<div id='" + this.prefix + "boxbar' class='" + this.prefix + "boxbar'>"
				+ "<span><a id='" + this.prefix + "boxbarmax' class='" + this.prefix + "boxbarmax' " + (this.forceStyles ? "style='color:white' " : "") + "href='#'><img src='" + SDK.url + "/images/maximizew.png'> " + this.caption + " </a>"
				+ " <a id='" + this.prefix + "boxclose' class='" + this.prefix + "boxclose' href='#'> <img src='" + SDK.url + "/images/closeg.png'></a></span><br/>"
				+ "</span>"
			+ "</div>\n";
		
		إذا (هذه. معلومات الاتصال الموجهة) {
			html = html
				+ "<div id='" + this.prefix + "contactinfo' class='" + this.prefix + "box' " + backgroundstyle + ">"
					+ "<div class='" + this.prefix + "boxmenu'>"
						+ "<span style='float:right'><a id='" + this.prefix + "contactboxmin' class='" + this.prefix + "boxmin' href='#'><img src='" + SDK.url + "/images/minimize.png'></a>"
					+ "</div>\n"
					+ "<div style='margin:10px'>\n"
						+ "<span>الاسم</span><br/><input id='" + this.prefix + "contactname' type='text' /><br/>\n"
						+ "<span>البريد الإلكتروني</span><br/><input id='" + this.prefix + "contactemail' type='email' /><br/>\n"
						+ "<span>الهاتف</span><br/><input id='" + this.prefix + "contactphone' type='text' /><br/>\n"
						+ "<br/><a id='" + this.prefix + "contactconnect' class='" + this.prefix + "contactconnect' " + (this.forceStyles ? "style='color:white' " : "") + "href='#'>Connect</a>\n"
					+ "</div>\n"
				+ "</div>";
		}
		
		الصندوق الداخليHTML = html؛
		المستند.الجسم.appendChild(الصندوق)؛
		
		var self = هذا؛
		var listen = false؛
		document.getElementById(هذا.prefix + "chat").addEventListener("keypress", function(event) {
			إذا (event.keyCode == 13) {
				self.sendMessage();
				العودة كاذبة؛
			}
		});
		document.getElementById(هذا.prefix + "خروج").addEventListener("انقر فوق"، دالة() {
			الخروج الذاتي();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "ping").addEventListener("انقر فوق"، دالة() {
			self.ping();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "مسح").addEventListener("انقر فوق"، دالة() {
			ذاتي. واضح();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "قبول").addEventListener("انقر"، دالة() {
			قبول الذات();
			العودة كاذبة؛
		});
		document.getElementById(this.prefix + "sendImage").addEventListener("click", function() {
			self.sendImage();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "sendAttachment").addEventListener("انقر فوق"، دالة() {
			self.sendAttachment();
			العودة كاذبة؛
		});
		var menu = document.getElementById(this.prefix + "flag");
		إذا (القائمة != null) {
			القائمة.addEventListener("انقر فوق"، دالة() {
				علم ذاتي();
				العودة كاذبة؛
			});
		}
		القائمة = document.getElementById(هذا.prefix + "همس");
		إذا (القائمة != null) {
			القائمة.addEventListener("انقر فوق"، دالة() {
				همس الذات();
				العودة كاذبة؛
			});
		}
		القائمة = document.getElementById(هذا.prefix + "pvt");
		إذا (القائمة != null) {
			القائمة.addEventListener("انقر فوق"، دالة() {
				ذاتي.pvt();
				العودة كاذبة؛
			});
		}
		document.getElementById(هذا.prefix + "toggleChime").addEventListener("انقر"، دالة() {
			self.toggleChime();
			إذا (self.playChime) {
				المستند.getElementById('boxchime').src = SDK.url + "/images/sound.png";
			} آخر {
				المستند.getElementById('boxchime').src = SDK.url + "/images/mute.png";
			}
		});
		document.getElementById(هذا.prefix + "toggleSpeak").addEventListener("انقر"، دالة() {
			self.toggleSpeak();
			إذا (تكلمت بنفسي) {
				المستند.getElementById('boxtalk').src = SDK.url + "/images/talk.png";
			} آخر {
				المستند.getElementById('boxtalk').src = SDK.url + "/images/talkoff.png";
			}
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "toggleListen").addEventListener("انقر فوق"، دالة() {
			استمع = !استمع؛
			إذا (استمع) {
				SDK.startSpeechRecognition();
				المستند.getElementById('boxmic').src = SDK.url + "/images/mic.png";
			} آخر {
				SDK.stopSpeechRecognition();
				المستند.getElementById('boxmic').src = SDK.url + "/images/micoff.png";
			}
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "boxclose").addEventListener("انقر فوق"، دالة() {
			أغلق الصندوق الذاتي();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "boxmin").addEventListener("انقر فوق"، دالة() {
			self.minimizeBox();
			العودة كاذبة؛
		});
		إذا (هذه. معلومات الاتصال الموجهة) {
			document.getElementById(this.prefix + "contactboxmin").addEventListener("click"، function() {
				self.minimizeBox();
				العودة كاذبة؛
			});
			document.getElementById(this.prefix + "contactconnect").addEventListener("click"، function() {
				self.contactConnect();
				العودة كاذبة؛
			});
		}
		document.getElementById(هذا.prefix + "boxmax").addEventListener("انقر فوق"، دالة() {
			self.popup();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "boxbarmax").addEventListener("انقر فوق"، دالة() {
			self.maximizeBox();
			العودة كاذبة؛
		});
	}
	
	/**
	 * تقليل حجم قسم التضمين في صفحة الويب الحالية.
	 */
	هذا.minimizeBox = دالة () {
		إذا (هذه. معلومات الاتصال الموجهة) {
			document.getElementById(هذا.prefix + "معلومات الاتصال").style.display = 'لا شيء';
		}
		document.getElementById(هذا.prefix + "box").style.display = 'لا شيء';
		document.getElementById(هذا.prefix + "boxbar").style.display = 'inline';
		إذا (هذا.prefix.indexOf("الدردشة المباشرة") != -1) {
			var chatbot = document.getElementById(this.prefix.substring(0, this.prefix.indexOf("الدردشة الحية")) + "boxbar");
			إذا (روبوت الدردشة != null) {
				chatbot.style.display = 'مضمن';
			}
		}
		هذا.الخروج();
		تعيين الوقت(دالة() {
		    الخروج الذاتي();
		}, 100);
		العودة كاذبة؛
	}
	
	/**
	 * التحقق من معلومات الاتصال والتواصل.
	 */
	هذا.contactConnect = دالة () {
		هذا.hasContactInfo = صحيح؛
		هذا.اسم جهة الاتصال = document.getElementById(هذا.بادئة + "اسم جهة الاتصال").القيمة؛
		var ok = صحيح؛
		إذا (هذا.اسم جهة الاتصال != null و هذا.اسم جهة الاتصال == "") {
			حسناً = خطأ؛
			document.getElementById(هذا.prefix + "اسم جهة الاتصال").style.borderColor = "أحمر";
			document.getElementById(this.prefix + "contactname").placeholder = "أدخل الاسم";
		}
		هذا.contactEmail = document.getElementById(هذا.prefix + "contactemail").value؛
		إذا (هذا.contactEmail != null و هذا.contactEmail.indexOf("@") == -1) {
			حسناً = خطأ؛
			document.getElementById(this.prefix + "contactemail").style.borderColor = "أحمر";
			document.getElementById(this.prefix + "contactemail").placeholder = "أدخل بريدًا إلكترونيًا صالحًا";
		}
		هذا.هاتف جهة الاتصال = document.getElementById(هذا.بادئة + "هاتف جهة الاتصال").القيمة؛
		هذا.معلومات الاتصال = هذا.اسم جهة الاتصال + " " + هذا.بريد جهة الاتصال الإلكتروني + " " + هذا.هاتف جهة الاتصال؛
		إذا (حسنا) {
			هذا.تكبيرالصندوق();
		}
	}
	
	/**
	 * تكبير قسم التضمين في صفحة الويب الحالية.
	 */
	هذا.maximizeBox = دالة () {
		إذا (هذا. معلومات الاتصال الفوري و! هذا. لديه معلومات الاتصال) {
			document.getElementById(هذا.prefix + "معلومات الاتصال").style.display = 'inline';
			document.getElementById(هذا.prefix + "boxbar").style.display = 'لا شيء';
			document.getElementById(هذا.prefix + "box").style.display = 'لا شيء';
			إذا (هذا.prefix.indexOf("الدردشة المباشرة") != -1) {
				var chatbot = document.getElementById(this.prefix.substring(0, this.prefix.indexOf("الدردشة الحية")) + "boxbar");
				إذا (روبوت الدردشة != null) {
					chatbot.style.display = 'لا شيء';
				}
			}
		} آخر {
			إذا (هذه. معلومات الاتصال الموجهة) {
				document.getElementById(هذا.prefix + "معلومات الاتصال").style.display = 'لا شيء';
			}
			document.getElementById(هذا.prefix + "boxbar").style.display = 'لا شيء';
			document.getElementById(هذا.prefix + "box").style.display = 'inline';
			إذا (هذا.prefix.indexOf("الدردشة المباشرة") != -1) {
				var chatbot = document.getElementById(this.prefix.substring(0, this.prefix.indexOf("الدردشة الحية")) + "boxbar");
				إذا (روبوت الدردشة != null) {
					chatbot.style.display = 'لا شيء';
				}
			}
		    var chat = new LiveChatConnection();
		    chat.sdk = هذا.sdk؛
		    إذا (this.contactInfo != null) {
		    	معلومات الاتصال = هذه معلومات الاتصال؛
		    }
		    var channel = new ChannelConfig();
		    القناة.id = هذه الحالة؛
		    chat.listener = هذا؛
			chat.connect(القناة، هذا.sdk.user)؛
		}
		العودة كاذبة؛
	}
	
	/**
	 * إغلاق قسم التضمين في صفحة الويب الحالية.
	 */
	هذا.إغلاق الصندوق = دالة () {
		إذا (هذه. معلومات الاتصال الموجهة) {
			document.getElementById(هذا.prefix + "معلومات الاتصال").style.display = 'لا شيء';
		}
		document.getElementById(هذا.prefix + "boxbar").style.display = 'لا شيء';
		document.getElementById(هذا.prefix + "box").style.display = 'لا شيء';
		إذا (هذا.prefix.indexOf("الدردشة المباشرة") != -1) {
			var chatbot = document.getElementById(this.prefix.substring(0, this.prefix.indexOf("الدردشة الحية")) + "boxbar");
			إذا (روبوت الدردشة != null) {
				chatbot.style.display = 'لا شيء';
			}
		}
		هذا.الخروج();
		var self = هذا؛
		تعيين الوقت(دالة() {
		    الخروج الذاتي();
		}, 100);
		العودة كاذبة؛		
	}
	
	/**
	 * إنشاء نافذة منبثقة لجلسة الدردشة المباشرة.
	 */
	هذه النافذة المنبثقة = دالة () {
		var box = document.getElementById(هذا.prefix + "box");
		إذا (الصندوق != null) {
			box.style.display = 'لا شيء';
		}
		إذا (هذا.popupURL != null) {
			var popupURL = هذا.popupURL؛
			إذا (popupURL.indexOf("الدردشة المباشرة؟") != -1 && this.contactInfo != null && this.contactInfo != "") {
				عنوان URL المنبثق = عنوان URL المنبثق + "&info=" + encodeURI(هذا.معلومات الاتصال)؛
			}
			SDK.popupwindow(popupURL، 'الطفل'، 700، 520)؛
		} آخر {
		    var form = document.createElement("form");
            form.setAttribute("الطريقة"، "النشر");
            form.setAttribute("action"، SDK.url + "/livechat");
            form.setAttribute("الهدف"، 'الطفل');
 
            var input = document.createElement('input');
            الإدخال.نوع = "مخفي";
            الإدخال.الاسم = "المعرف"؛
            الإدخال.القيمة = هذه.المثال؛
            نموذج.appendChild(الإدخال)؛
 
            الإدخال = document.createElement('الإدخال');
            الإدخال.نوع = "مخفي";
            الإدخال.الاسم = "مضمن"؛
            الإدخال.القيمة = "مضمن"؛
            نموذج.appendChild(الإدخال)؛
 
            الإدخال = document.createElement('الإدخال');
            الإدخال.نوع = "مخفي";
            الإدخال.الاسم = "الدردشة"؛
            الإدخال.القيمة = "صحيح"؛
            نموذج.appendC hild(الإدخال)؛
 
            الإدخال = document.createElement('الإدخال');
            الإدخال.نوع = "مخفي";
            input.name = "التطبيق";
            الإدخال.القيمة = هذا.الاتصال.بيانات الاعتماد.معرف التطبيق؛
            نموذج.appendChild(الإدخال)؛
 
            الإدخال = document.createElement('الإدخال');
            الإدخال.نوع = "مخفي";
            الإدخال.الاسم = "المعلومات"؛
            الإدخال.القيمة = هذه.معلومات الاتصال؛
            نموذج.appendChild(الإدخال)؛
            
            المستند.الجسم.appendChild(النموذج)؛
            
			SDK.popupwindow('','child', 700, 520);
			
			نموذج الإرسال();
            المستند.الجسم.إزالة الطفل(النموذج)؛
		}
		هذا.تصغير المربع();
		العودة كاذبة؛
	}
	
	window.onfocus = دالة () {
		self.isActive = صحيح؛
		إذا (عنوان المستند != عنوان النافذة الذاتية) {
			المستند.العنوان = self.windowTitle؛
		}
	};

	window.onblur = دالة () {
		self.isActive = false؛
	};
		
	/**
	 * تم استلام رسالة مستخدم من القناة.
	 */
	هذه الرسالة = دالة (الرسالة) {
		فار فهرس = message.indexOf(':');
		var speaker = '';
		إذا (المؤشر != -1) {
			المتحدث = الرسالة. سلسلة فرعية (0، الفهرس + 1)؛
			responseText = message.substring(index + 2, message.length);
		} آخر {
			responseText = الرسالة؛
		}
		إذا (المتحدث != (هذا.الاسم + ':')) {
			إذا (هذا.تشغيل الرنين) {
				SDK.chime();
			}
			إذا (هذا الكلام) {
				SDK.tts(SDK.stripTags(نص الاستجابة)، هذا.الصوت، هذا.الصوت الأصلي، هذه.اللغة، هذا.اسم الصوت الأصلي)؛
			}
			document.getElementById(هذا.prefix + 'الاستجابة').innerHTML = SDK.linkURLs(الرسالة)؛
		}
		var scroller = document.getElementById(this.prefix + 'scroller');
		var consolepane = document.getElementById(this.prefix + 'console');
		إذا (الشريط التمرير == لا شيء || لوحة التحكم == لا شيء) {
			يعود؛
		}
		إذا (this.chatLogType == "سجل") {
			var tr = document.createElement('tr');
			var td = document.createElement('td');
			var span = document.createElement('span');
			var br = document.createElement('br');
			var span2 = document.createElement('span');
			var chatClass = this.prefix + 'chat-1';
			إذا (هذا.switchText) {
				chatClass = this.prefix + 'chat-2';
			}
			span.className = this.prefix + 'chat-user';
			var date = new Date();
			var time = date.getHours() + ":" + ((date.getMinutes() < 10)? "0" : "") + date.getMinutes() + ":" + ((date.getSeconds() < 10)? "0" : "") + date.getSeconds();
			span.innerHTML = speaker + " <small>" + time + " </small>";
			span2.className = chatClass؛
			span2.innerHTML = SDK.linkURLs(نص الاستجابة)؛
			td.className = chatClass؛
			td.setAttribute('العرض', '100%');
			td.setAttribute('محاذاة', 'يسار');
			consolepane.appendChild(tr);
			tr.appendChild(td);
			td.appendChild(span);
			td.appendChild(br);
			td.appendChild(span2);			
		} آخر {
			var tr = document.createElement('tr');
			var td = document.createElement('td');
			var td2 = document.createElement('td');
			var span = document.createElement('span');
			var span2 = document.createElement('span');
			var chatClass = this.prefix + 'chat-1';
			إذا (هذا.switchText) {
				chatClass = this.prefix + 'chat-2';
			}
			span.className = chatClass؛
			span.innerHTML = المتحدث؛
			span2.className = chatClass؛
			span2.innerHTML = SDK.linkURLs(نص الاستجابة)؛
			td.className = this.prefix + 'chat-user';
			td.setAttribute('nowrap', 'nowrap');
			td2.className = chatClass؛
			td2.setAttribute('محاذاة', 'يسار');
			td2.setAttribute('العرض', '100%');
			consolepane.appendChild(tr);
			tr.appendChild(td);
			td.appendChild(span);
			tr.appendChild(td2);
			td2.appendChild(span2);
		}
		هذا.switchText = !هذا.switchText؛
		بينما (consolepane.childNodes.length > 500) {
			consolepane.removeChild(consolepane.firstChild);
		}
		scroller.scrollTop = scroller.scrollHeight؛
		إذا (هذا التركيز) {
			المستند.getElementById(هذا.prefix + 'chat').focus();
		}
		إذا لم يكن هذا نشطًا
			المستند.العنوان = SDK.stripTags(نص الاستجابة)؛
		}
	};

	
	/**
	 *تم استلام رسالة إعلامية من القناة.
	 * مثل انضمام مستخدم جديد، أو طلب خاص، وما إلى ذلك.
	 */	
	هذه.info = دالة(الرسالة) {
		إذا (هذا.الاتصال.النيك != لا شيء و هذا.الاتصال.النيك != "") {
			هذا.النيك = هذا.الاتصال.النيك؛
		}
		هذه الرسالة(الرسالة);
	};

	/**
	 * تم استلام رسالة خطأ من القناة.
	 * قد يكون هذا خطأ في الوصول، أو فشل في الرسالة.
	 */	
	هذا الخطأ = دالة (الرسالة) {
		هذه الرسالة(الرسالة);
	};
	
	/**
	 * إشعار بأن الاتصال تم إغلاقه.
	 */
	هذا.مغلق = دالة () {}؛
	
	/**
	 * القنوات التي قام المستخدمون بتغييرها (انضم المستخدم، غادر، إلخ.)
	 * يحتوي هذا على قائمة قيم مفصولة بفاصلة (CSV) لمستخدمي القناة الحاليين.
	 * يمكن تمريره إلى واجهة برمجة التطبيقات SDKConnection.getUsers() للحصول على معلومات UserConfig للمستخدمين.
	 */
	هذا.تحديث المستخدمين = دالة (المستخدمين CSV) {}؛

	/**
	 * القنوات التي قام المستخدمون بتغييرها (انضم المستخدم، غادر، إلخ.)
	 * يحتوي هذا على قائمة HTML لمستخدمي القناة الحاليين.
	 * يمكن إدراجه في مستند HTML لعرض المستخدمين.
	 */
	هذا.تحديثالمستخدمينXML = دالة(المستخدمينXML) {
		var onlineList = document.getElementById(this.prefix + 'online');
		إذا (onlineList == null) {
			يعود؛
		}
		القائمة عبر الإنترنت.innerHTML = '';
		var div = document.createElement('div');
		إذا لم يكن هذا الرابط للمستخدمين
			المستخدمونXML = المستخدمونXML.split('<a').join('<span');
			المستخدمونXML = المستخدمونXML.split('</a>').join('</span>');
		}
		div.innerHTML = المستخدمينXML؛
		var children = div.childNodes[0].childNodes;
		عدد المتغيرات = 0؛
		var length = children.length؛
		المعرف المتغير = {}؛
		// إضافة المستخدم المفقود
		بالنسبة إلى (var i = 0؛ i < الطول؛ i++) {
			var child = children[i - count]؛
			معرفات[معرف الطفل] = معرف الطفل؛
			إذا (document.getElementById(child.id) == null) {
				onlineList.appendChild(الطفل)؛
				العد++؛
			}
		}
		// إزالة المستخدمين المفقودين
		var onlineDiv = document.getElementById(هذا.prefix + 'online-div');
		إذا (onlineDiv == null) {
			يعود؛
		}
		الأطفال = onlineDiv.childNodes؛
		العد = 0؛
		الطول = طول الأطفال؛
		بالنسبة إلى (var i = 0؛ i < الطول؛ i++) {
			var child = children[i - count]؛
			إذا (معرف الطفل != (هذا البادئة + 'متصل') ومعرفات[معرف الطفل] == لا شيء) {
				onlineDiv.removeChild(الطفل)؛
				العد++؛
			}
		}
	};

	/**
	 * تقليل حجم عنصر الفيديو لمعرف المستخدم.
	 */
	هذا.shrinkVideo = دالة(المستخدم) {
	    المتغير id = 'user-' + encodeURIComponent(المستخدم)؛
	    فار userdiv = document.getElementById(id);
	    إذا (userdiv != null) {
	    	var media = userdiv.firstElementChild;	    	
			إذا (الوسائط != null) {
				ارتفاع الوسائط = ارتفاع الوسائط / 1.5؛
			}
		}
	};

	/**
	 * زيادة حجم عنصر الفيديو لمعرف المستخدم.
	 */
	هذا.expandVideo = دالة(المستخدم) {
	    المتغير id = 'user-' + encodeURIComponent(المستخدم)؛
	    فار userdiv = document.getElementById(id);
	    إذا (userdiv != null) {
	    	var media = userdiv.firstElementChild;	    	
			إذا (الوسائط != null) {
				ارتفاع الوسائط = ارتفاع الوسائط * 1.5؛
			}
		}
	};

	/**
	 * كتم الصوت لمعرف المستخدم.
	 */
	هذا.muteAudio = دالة(المستخدم) {
	    المتغير id = 'user-' + encodeURIComponent(المستخدم)؛
	    فار userdiv = document.getElementById(id);
	    إذا (userdiv != null) {
	    	var media = userdiv.firstElementChild;	    	
			إذا (الوسائط != null) {
				إذا (تم كتم الوسائط) {
					إذا (المستخدم != هذا الاسم) {
						media.muted = false؛
					}
				} آخر {
					media.muted = صحيح؛					
				}
			}
		}
	};

	/**
	 * كتم صوت الفيديو لمعرف المستخدم.
	 */
	هذا.كتم الفيديو = دالة(المستخدم) {
	    المتغير id = 'user-' + encodeURIComponent(المستخدم)؛
	    فار userdiv = document.getElementById(id);
	    إذا (userdiv != null) {
	    	var media = userdiv.firstElementChild;	    	
			إذا (الوسائط != null) {
				إذا (توقفت الوسائط مؤقتًا) {
					الوسائط.play();
					media.style.opacity = 100؛
				} آخر {
					الوسائط.توقف مؤقت();
					media.style.opacity = 0؛					
				}
			}
		}
	};

	هذا.toggleChime = دالة () {
		هذا.playChime = !هذا.playChime؛
	}

	هذا.toggleSpeak = دالة () {
		هذا.تكلم = !هذا.تكلم؛
	}

	هذا.toggleKeepAlive = دالة () {
		هذا.الاتصال.toggleKeepAlive();
	}
	
	هذه.إرسال الرسالة = دالة () {
		var message = document.getElementById(this.prefix + 'chat').value؛
		إذا (الرسالة != '') {
			هذا.الاتصال.إرسال رسالة(الرسالة)؛
			document.getElementById(هذا.prefix + 'دردشة').value = '';
		}
		العودة كاذبة؛
	};

	هذا.ارسال الصورة = دالة () {
		إذا لم ((نافذة.ملف ونافذة.قارئ الملفات ونافذة.قائمة الملفات ونافذة.كائن كبير)) {
			alert('لا يتم دعم واجهات برمجة التطبيقات للملفات بشكل كامل في هذا المتصفح.');
			العودة كاذبة؛
		}
		var form = document.createElement("form");
		form.enctype = "multipart/form-data";
		النموذج.الطريقة = "نشر"؛
		النموذج.الاسم = "معلومات الملف"؛
		var fileInput = document.createElement("input");
		var self = هذا؛
		fileInput.name = "ملف";
		fileInput.type = "ملف";
		النموذج.appendChild(إدخال الملف)؛
		fileInput.onchange = دالة () {
			var file = fileInput.files[0];
			self.connection.sendAttachment(ملف، صحيح، نموذج)؛
		}
		fileInput.click();
		العودة كاذبة؛
	};

	هذا.sendAttachment = دالة () {
		إذا لم ((نافذة.ملف ونافذة.قارئ الملفات ونافذة.قائمة الملفات ونافذة.كائن كبير)) {
			alert('لا يتم دعم واجهات برمجة التطبيقات للملفات بشكل كامل في هذا المتصفح.');
			العودة كاذبة؛
		}
		var form = document.createElement("form");
		form.enctype = "multipart/form-data";
		النموذج.الطريقة = "نشر"؛
		النموذج.الاسم = "معلومات الملف"؛
		var fileInput = document.createElement("input");
		var self = هذا؛
		fileInput.name = "ملف";
		fileInput.type = "ملف";
		النموذج.appendChild(إدخال الملف)؛
		fileInput.onchange = دالة () {
			var file = fileInput.files[0];
			self.connection.sendAttachment(ملف، خطأ، نموذج)؛
		}
		fileInput.click();
		العودة كاذبة؛
	};

	هذا.ping = دالة () {
		هذا.الاتصال.ping();
		document.getElementById(هذا.prefix + 'دردشة').value = '';
		العودة كاذبة؛
	};

	هذا.قبول = دالة () {
		هذا.الاتصال.قبول();
		document.getElementById(هذا.prefix + 'دردشة').value = '';
		العودة كاذبة؛
	};

	هذا.الخروج = دالة () {
		إذا (هذا الاتصال != null) {
			هذا.الاتصال.الخروج();
			document.getElementById(هذا.prefix + 'دردشة').value = '';
		}
		العودة كاذبة؛
	};

	هذا.spyMode = دالة () {
		هذا.connection.spyMode();
		document.getElementById(هذا.prefix + 'دردشة').value = '';
		العودة كاذبة؛
	};

	هذا.الوضع الطبيعي = دالة () {
		هذا.الاتصال.الوضع الطبيعي();
		document.getElementById(هذا.prefix + 'دردشة').value = '';
		العودة كاذبة؛
	};

	هذا.boot = دالة () {
		document.getElementById(this.prefix + 'chat').value = 'boot: user';
		العودة كاذبة؛
	};

	هذا.الهمس = دالة(المستخدم) {
		إذا (المستخدم == null) {
			المستخدم = 'المستخدم';
		}
		document.getElementById(هذا.prefix + 'chat').value = 'whisper: ' + user + ': message';
		العودة كاذبة؛
	};

	هذا.العلم = دالة(المستخدم) {
		إذا (المستخدم != null) {
			document.getElementById(this.prefix + 'chat').value = 'flag: ' + user + ': reason';
			العودة كاذبة؛
		}
		document.getElementById(this.prefix + 'chat').value = 'flag: user: reason';
		العودة كاذبة؛
	};

	هذا.pvt = دالة(المستخدم) {
		إذا (المستخدم != null) {
			هذا.connection.pvt(المستخدم)؛
			العودة كاذبة؛
		}
		document.getElementById(this.prefix + 'chat').value = 'خاص: مستخدم';
		العودة كاذبة؛
	};

	هذا.clear = دالة () {
		document.getElementById(هذا.prefix + 'الاستجابة').innerHTML = '';
		var console = document.getElementById(this.prefix + 'console');
		إذا (وحدة التحكم != null) {
			console.innerHTML = '';
		}
		العودة كاذبة؛
	};
}

/**
 * طريقة مشتركة لتحديث صورة الرمز/الفيديو/الصوت من استجابة الدردشة.
 */
SDK.updateAvatar = function(responseMessage، speak، urlprefix، elementPrefix، channelaudio، afterFunction، nativeVoice، lang، voice) {
	nativeVoice = nativeVoice && SDK.speechSynthesis؛
	إذا (elementPrefix == null) {
		elementPrefix = "";
	}
	var avatarStatus = document.getElementById(elementPrefix + "avatar-status");
	إذا (avatarStatus != null) {
		var status = "";
		إذا (responseMessage.emote != null && responseMessage.emote != "" && responseMessage.emote != "NONE") {
			الحالة = responseMessage.emote.toLowerCase();
		}
		إذا (responseMessage.action != null && responseMessage.action != "") {
			إذا (الحالة != "") {
				الحالة = الحالة + " : "؛
			}
			الحالة = الحالة + responseMessage.action؛
		}
		إذا (responseMessage.pose != null && responseMessage.pose != "") {
			إذا (الحالة != "") {
				الحالة = الحالة + " : "؛
			}
			الحالة = الحالة + رسالة الاستجابة.وضع؛
		}
		avatarStatus.innerHTML = الحالة؛
	}
	إذا (responseMessage.avatarActionAudio != null && تحدث) {
		var audio = صوت جديد (urlprefix + responseMessage.avatarActionAudio)؛
		الصوت.تشغيل();
	}
	إذا لم يكن (speak || SDK.currentBackgroundAudio != responseMessage.avatarAudio) {
		// قم بالتبديل فقط إذا كان الصوت مختلفًا.
		إذا (SDK.backgroundAudio != null) {
			SDK.backgroundAudio.pause();
			SDK.currentBackgroundAudio = null؛
		}
		إذا (responseMessage.avatarAudio != null && تحدث) {
			SDK.currentBackgroundAudio = responseMessage.avatarAudio؛
			SDK.backgroundAudio = صوت جديد (urlprefix + responseMessage.avatarAudio)؛
			SDK.backgroundAudio.loop = صحيح؛
			SDK.backgroundAudio.play();
		}
	}
	إذا (responseMessage.avatarType != null && responseMessage.avatarType.indexOf("video") != -1) {
		var div = document.getElementById(elementPrefix + "avatar-image-div");
		إذا (div != null) {
			div.style.display = "لا شيء";
		}
		div = document.getElementById(elementPrefix + "avatar-video-div");
		var canvas = null؛
		إذا (div != null) {
			div.style.display = "inline-block";
			إذا (responseMessage.avatarBackground != null) {
				div.style.backgroundImage = "url(" + urlprefix + responseMessage.avatarBackground + ")";
			}
			var CanvasDiv = document.getElementById(elementPrefix + "avatar-canvas-div");
			إذا (((SDK.isChrome() && !SDK.isMobile()) || SDK.isFirefox() || SDK.useCanvas == true) && SDK.useCanvas != false && canvasDiv != null) {
				div.style.position = "ثابت";
				النمط.الأعلى = "-1000";
				النمط الأيسر = "-1000";
				div.style.opacity = "0";
				div.style.zIndex = "-1";
				canvasDiv.style.display = "inline-block";
				القماش = document.getElementById(elementPrefix + "avatar-canvas");
			}
		}
		var video = document.getElementById(elementPrefix + "avatar-video");
		إذا (الفيديو == لا شيء) {
			إذا (تكلم) {
				إذا (الصوت الأصلي) {
					SDK.tts(SDK.stripTags(responseMessage.message)، لا شيء، صحيح، لغة، صوت)؛
				} آخر {
					var audio = SDK.play(urlprefix + responseMessage.speech، channelaudio)؛
					audio.onended = afterFunction؛
				}
			}
			يعود؛
		} آخر {
			إذا (responseMessage.avatar.indexOf("mp4") != -1 && (SDK.isChrome() || SDK.isFirefox() || SDK.fixBrightness != true) && SDK.fixBrightness != false) {
				// خدعة لإصلاح الخلفية الرمادية في Chrome.
				إذا (SDK.isChrome()) {
					video.style.webkitFilter = "السطوع (108.5٪)";
				} آخر {
					video.style["filter"] = "السطوع(1.085)";
				}
				إذا (اللوحة القماشية != null) {
					إذا (SDK.isChrome()) {
						canvas.style.webkitFilter = "السطوع (108.5٪)";
					} آخر {
						video.style["filter"] = "السطوع(1.085)";
					}
				}
			}
			إذا (اللوحة == لا شيء) {
				إذا (responseMessage.avatarBackground != null) {
					video.poster = urlprefix + responseMessage.avatarBackground؛				
				}
			}
		}
		var السياق = null؛
		var drawCanvas = null؛
		إذا (اللوحة القماشية != null) {
		    السياق = canvas.getContext('2d');
			إذا (SDK.timers[elementPrefix + "avatar-canvas"] == null) {
				رسم القماش = دالة () {
				    إذا لم يتم إيقاف الفيديو مؤقتًا و لم يتم إنهاء الفيديو و الوقت الحالي للفيديو > 0) {
				    	إذا (عرض القماش لا يساوي عرض إزاحة الفيديو) {
				    		عرض القماش = عرض إزاحة الفيديو؛
				    	}
				    	إذا (ارتفاع القماش != ارتفاع إزاحة الفيديو) {
				    		قماش.الارتفاع = فيديو.إزاحة الارتفاع؛
				    	}
				    	السياق.clearRect(0، 0، عرض القماش، ارتفاع القماش)؛
				    	السياق. رسم الصورة (فيديو، 0، 0، عرض إزاحة الفيديو، ارتفاع إزاحة الفيديو)؛
				    }
				}
				SDK.timers[elementPrefix + "avatar-canvas"] = drawCanvas؛
				setInterval(رسم القماش، 20)؛				
			}
		}
		var end = function() {
			video.src = urlprefix + responseMessage.avatar؛
			إذا (responseMessage.avatar2 == null) {
				video.loop = صحيح؛
			} آخر {
				video.loop = false؛
				الفيديو.onended = function() {
					var index = Math.floor(Math.random() * 5);
					إذا (index == 4 و responseMessage.avatar5 != null) {
						video.src = urlprefix + responseMessage.avatar5؛
					} وإلا إذا (index == 3 && responseMessage.avatar4 != null) {
						video.src = urlprefix + responseMessage.avatar4؛
					} وإلا إذا (index == 2 && responseMessage.avatar3 != null) {
						video.src = urlprefix + responseMessage.avatar3؛
					} وإلا إذا (index == 1 && responseMessage.avatar2 != null) {
						video.src = urlprefix + responseMessage.avatar2؛
					} آخر {
						video.src = urlprefix + responseMessage.avatar؛
					}
					فيديو.تشغيل();
				}
			}
			فيديو.تشغيل();
			إذا (afterFunction != null) {
				بعد الدالة();
			}
		}
		var talk = function() {
			إذا (responseMessage.message != null && responseMessage.message.length > 0) {
				إذا (responseMessage.avatarTalk != null) {
					إذا (تكلم) {
						إذا (responseMessage.speech == null && !nativeVoice) {
							نهاية()؛
						} آخر {
							video.src = urlprefix + responseMessage.avatar؛
							video.loop = صحيح؛
							var playing = false؛
							فيديو.تشغيل();
	
							إذا (الصوت الأصلي) {
								var utterance = new SpeechSynthesisUtterance(SDK.stripTags(responseMessage.message));
								SDK.utterance = اللفظ؛
								utterance.onstart = function() {
									إذا (يلعب) {
										العودة كاذبة؛
									}
									إذا ('speechSynthesis' في النافذة) {
										الكلام التوليف.pause();
									}
									video.src = urlprefix + responseMessage.avatarTalk؛
									video.loop = صحيح؛
									video.oncanplay = دالة () {
										إذا (يلعب) {
											العودة كاذبة؛
										}
										اللعب = صحيح؛
										إذا ('speechSynthesis' في النافذة) {
											الكلام التوليفي.استئناف();
										}
									}
									فيديو.تشغيل();
								}
								utterance.onerror = function() {
									console.log("خطأ");
									نهاية()؛
								}
								utterance.onend = function() {
									نهاية()؛
								}
								
								SDK.nativeTTS(اللفظ، اللغة، الصوت)؛
							} آخر {
								//var audio = صوت جديد(urlprefix + responseMessage.speech، channelaudio)؛
								var audio = SDK.play(urlprefix + responseMessage.speech، channelaudio)؛
								//audio.onabort = function() {console.log("abort");}
								audio.oncanplay = دالة () {
									إذا (يلعب) {
										العودة كاذبة؛
									}
									الصوت.توقف مؤقت();
									video.src = urlprefix + responseMessage.avatarTalk؛
									video.loop = صحيح؛
									video.oncanplay = دالة () {
										إذا (يلعب) {
											العودة كاذبة؛
										}
										اللعب = صحيح؛
										الصوت.تشغيل();
									}
									فيديو.تشغيل();
								}
								audio.onerror = دالة () {
									console.log("خطأ");
									نهاية()؛
								}
								//audio.onloadeddata = function() {console.log("loadeddata");}
								//audio.onloadedmetadata = function() {console.log("loadedmetadata");}
								//audio.onpause = function() {console.log("pause");}
								//audio.onplay = function() {console.log("play");}
								//audio.onplaying = function() {console.log("playing");}
								//audio.ontimeupdate = function() {console.log("timeupdate");}
								audio.onended = function() {
									نهاية()؛
								}
								الصوت.تشغيل();
								فيديو.تشغيل();
							}
						}
					} آخر {
						video.src = urlprefix + responseMessage.avatarTalk؛
						video.loop = false؛
						فيديو.تشغيل();
						الفيديو.onended = function() {
							نهاية()؛
						}
					}
				} آخر {
					video.src = urlprefix + responseMessage.avatar؛
					video.loop = صحيح؛
					فيديو.تشغيل();
					إذا (تكلم) {
						إذا (الصوت الأصلي) {
							var utterance = new SpeechSynthesisUtterance(SDK.stripTags(responseMessage.message));
							utterance.onend = afterFunction؛
							SDK.nativeTTS(اللفظ، اللغة، الصوت)؛
						} آخر {
							var audio = SDK.play(urlprefix + responseMessage.speech، channelaudio)؛
							audio.onended = afterFunction؛						
						}
					} وإلا إذا (afterFunction != null) {
						بعد الدالة();			
					}
				}
			} آخر {
				نهاية()؛
			}
		}
		
		إذا (responseMessage.avatarAction != null) {
			video.src = urlprefix + responseMessage.avatarAction؛
			video.loop = false؛
			فيديو.تشغيل();
			الفيديو.onended = function() {
				يتحدث()؛
			}
		} آخر {
			يتحدث()؛
		}
	} آخر {
		var div = document.getElementById(elementPrefix + "avatar-video-div");
		إذا (div != null) {
			div.style.display = "لا شيء";
		}
		div = document.getElementById(elementPrefix + "avatar-canvas-div");
		إذا (div != null) {
			div.style.display = "لا شيء";
		}
		div = document.getElementById(elementPrefix + "avatar-image-div");
		إذا (div != null) {
			div.style.display = "inline-block";
		}
		var img = document.getElementById(elementPrefix + 'avatar');
		إذا (img != null) {
			img.src = urlprefix + responseMessage.avatar؛
		}
		img = document.getElementById(بادئة العنصر + 'avatar2');
		إذا (img != null) {
			img.src = urlprefix + responseMessage.avatar؛
		}
		إذا (تحدث و responseMessage.message != null و responseMessage.message.length > 0) {
			إذا (الصوت الأصلي) {
				SDK.tts(SDK.stripTags(responseMessage.message)، لا شيء، صحيح، لغة، صوت)؛
			} وإلا إذا كانت (responseMessage.speech != null) {
				var audio = SDK.play(urlprefix + responseMessage.speech، channelaudio)؛
				audio.onended = afterFunction؛
			}
		} وإلا إذا (afterFunction != null) {
			بعد الدالة();			
		}
	}
}

/**
 * يوفر WebChatbotListener تكاملاً بين محادثة روبوت الدردشة من خلال SDKConnection ومستند HTML.
 * يقوم بتحديث المستند بالرسائل المستلمة من الاتصال، ويرسل الرسائل من نموذج المستند.
 * تتطلب وثيقة HTML العناصر التالية:
 * <أول>
 * <li> chat - عنصر الإدخال (type='text') لإرسال الرسائل
 * <li>إرسال - زر الإدخال (النوع='إرسال') لإرسال مدخلات الدردشة
 * <li> الرد - عنصر فقرة p لرسالة الدردشة الأخيرة
 * <li> console - عنصر جدول لسجل الدردشة والصورة الرمزية
 * <li> scroller - عنصر div لجزء تمرير سجل الدردشة
 * <li> avatar - عنصر img لصورة رمزية للروبوت (اختياري)
 * <li> avatar2 - عنصر img الذي يتم تمريره فوق صورة رمزية للروبوت (اختياري)
 * <li> avatar-image-div - عنصر div لصورة الروبوت (اختياري)
 * <li> avatar-video - عنصر فيديو لفيديو الروبوت (اختياري)
 * <li> avatar-video-div - عنصر div لفيديو الروبوت (اختياري)
 * <li> avatar-status - عنصر span للحالة الحالية للبوت (اختياري)
 * </ul>
 * إذا تم تعيين بادئة، فسيتم وضع بادئة لهذه المعرفات.
 * أو يمكنك استدعاء createBox() لجعل WebChatbotListener يقوم بإنشاء مكوناته الخاصة في الصفحة الحالية.
 * @فصل
 */
وظيفة WebChatbotListener() {
	/** تعيين التسمية التوضيحية لزر شريط الأزرار. */
	هذا.caption = لا شيء؛
	/** منع الكلام. */
	هذا.السماح بالكلام = صحيح؛
	/** إزالة شريط القائمة. */
	هذا.showMenubar = صحيح؛
	/** إزالة اختيار اللغة. */
	هذا.showChooseLanguage = صحيح؛
	/** تمكين أو تعطيل الكلام. */
	هذا الكلام = صحيح؛
	/** قم بتكوين ما إذا كان يجب استخدام صوت TTS الأصلي للمتصفح. */
	هذا.nativeVoice = false؛
	/** تعيين اسم الصوت للصوت الأصلي. */
	هذا.nativeVoiceName = null؛
	/** تعيين اللغة للصوت الأصلي. */
	هذه.اللغة = لا شيء؛
	/** الترجمة بين لغة المستخدم ولغة الروبوت. */
	هذا.ترجمة = خطأ؛
	/** تمكين أو تعطيل الصورة الرمزية. */
	هذا.avatar = صحيح؛
	/** تعيين الصورة الرمزية. */
	هذا.avatarId = null؛
	/** قم بتحديد ما إذا كان يجب على الصورة الرمزية طلب فيديو/صور عالية الدقة (HD). */
	هذا.hd = لا شيء؛
	/** قم بتعيين ما إذا كان يجب على الصورة الرمزية طلب تنسيق فيديو أو صورة معين. */
	هذا.format = null؛
	/** يجب إعداد اتصال SDK، تأكد من تضمين معرف التطبيق الخاص بك. */
	هذا.الاتصال = لا شيء؛
	/** معرف أو اسم مثيل الروبوت الذي سيتم الاتصال به. */
	هذه الحالة = لا شيء؛
	/** الاسم الذي سيتم عرضه للبوت. */
	هذا.instanceName = "بوت";
	/** الاسم الذي سيتم عرضه للمستخدم. */
	هذا.اسم المستخدم = "أنت"؛
	/** السماح بتعيين لون الزر. */
	هذا.اللون = "#009900";
	/** السماح بتعيين لون زر التحويم. */
	هذا.hoverColor = "رمادي";
	/** السماح بتعيين لون الخلفية. */
	هذه الخلفية = لا شيء؛
	/** عرض صورة/فيديو الصورة الرمزية. */
	هذا العرض = 300؛
	/** ارتفاع صورة الرمز/الفيديو. */
	هذا.الارتفاع = لا شيء؛
	/** شريط الدردشة من الجانب. */
	هذا.الإزاحة = 30؛
	/** قم بتطبيق لون الخلفية فقط إذا لم يكن Chrome. */
	هذه.الخلفيةإذا لم تكن كروم = خطأ؛
	/** يتم رفع حدث onresponse بعد تلقي الاستجابة. */
	هذا.onresponse = null؛
	/** قم بتكوين ما إذا كان يجب التركيز على الدردشة بعد الرد. */
	هذا.التركيز = صحيح؛
	/** تجاوز عنوان URL المستخدم في النافذة المنبثقة لصندوق روبوت الدردشة. */
	هذا.popupURL = null؛
	/** طباعة الرد في فقاعة الدردشة. */
	هذه الفقاعة = خطأ؛
	/** الرسالة الأولية التي سيتم عرضها. */
	هذه التحية = لا شيء؛
	/** جاري تحميل الرسالة للعرض. */
	هذا.loading = "جاري التحميل...";
	/** معرف العنصر وبادئة الفئة. يسمح هذا لمعرف وبادئة الفئة بتجنب تضارب الأسماء في أسماء العناصر الخاصة بالدردشة والاستجابة ووحدة التحكم والصورة الرمزية.*/
	هذا.البادئة = "";
	/** يسمح بتعيين صورة مصغرة للروبوت لسجل الدردشة. */
	هذا.botالإبهام؛
	/** يسمح بتعيين صورة مصغرة للمستخدم لسجل الدردشة. */
	هذا.مستخدمThumb؛
	/** قم بتعيين الأنماط صراحةً لتجنب وراثة أنماط الصفحة. قم بتعطيل هذا لتتمكن من تجاوز الأنماط. */
	هذا.forceStyles = صحيح؛
	/** قم بتعيين موقع الزر والمربع، أحدها "أسفل اليمين"، "أسفل اليسار"، "أعلى اليمين"، "أعلى اليسار". */
	هذا.boxLocation = "أسفل اليمين";
	/** المطالبة بالاسم/البريد الإلكتروني قبل الاتصال. */
	هذا.promptContactInfo = false؛
	هذا.hasContactInfo = false؛
	هذا.اسم جهة الاتصال = لا شيء؛
	هذا.contactEmail = null؛
	هذا.هاتف الاتصال = لا شيء؛
	هذا.معلومات الاتصال = "";
	/** حدد ما إذا كان يجب عرض الارتباط الخلفي. */
	هذا.backlink = SDK.backlink؛

	/** دعم الاتصالات مع الروبوتات الخارجية من خلال واجهة برمجة التطبيقات على الويب. */
	هذا.الخارجي = خطأ؛
	هذا.apiURL = لا شيء؛
	هذا.apiPost = null؛
	هذا.apiResponse = null؛
	
	هذا.switchText = صحيح؛
	هذا.كبير = خطأ؛
	هذه المحادثة = لا شيء؛
	هذا.voiceInit = null؛
	هذا.استمع = خطأ؛
		
	/**
	 * إنشاء شريط تضمين و div في صفحة الويب الحالية.
	 */
	هذا.createBox = دالة () {
		إذا (هذا.prefix == "" و هذا.elementPrefix != null) {
			هذا.البادئة = هذا.العنصرالبادئة؛
		}
		إذا (هذا العنوان == لا شيء) {
			هذا.caption = هذا.instanceName؛
		}
		var backgroundstyle = "";
		var buttonstyle = "";
		var buttonHoverStyle = "";
		var hidden = "مخفي";
		var border = "";
		إذا (هذه الخلفية إذا لم تكن كروم وSDK.isChrome()) {
			هذه الخلفية = لا شيء؛
		}
		إذا (هذه الخلفية != null) {
			نمط الخلفية = "style='لون الخلفية:" + هذه.الخلفية + "'";
			مخفي = "مرئي"؛
			الحدود = "الحدود: 1 بكسل؛ نمط الحدود: صلب؛ لون الحدود: أسود؛";
		}
		إذا (هذا اللون لا يساوي null) {
			buttonstyle = "لون الخلفية:" + هذا.اللون + ";";
		}
		إذا (هذا.hoverColor != null) {
			buttonHoverStyle = "لون الخلفية:" + this.hoverColor + ";";
		}
		var minWidth = "";
		var divWidth = "";
		var background = "";
		var minHeight = "";
		var divHeight = "";
		إذا (هذا العرض != null) {
			الحد الأدنى للعرض = "العرض:" + هذا العرض + "بكسل؛"؛
			الخلفية = "حجم الخلفية:" + هذا العرض + "بيكسل تلقائي؛"؛
			عرض القسم = الحد الأدنى للعرض؛
			divHeight = "الحد الأدنى للارتفاع:" + هذا العرض + "بكسل؛";
			responseWidth = "العرض:" + (هذا العرض - 16) + "بكسل؛";
		}
		إذا (هذا الارتفاع != null) {
			الحد الأدنى للارتفاع = "الارتفاع:" + هذا الارتفاع + "بكسل؛"؛
			ارتفاع القسم = الحد الأدنى للارتفاع؛
			إذا (هذا العرض != null) {
				الخلفية = "حجم الخلفية:" + هذا. العرض + "بكسل" + هذا. الارتفاع + "بكسل؛"؛
			} آخر {
				الخلفية = "حجم الخلفية: تلقائي" + هذا.الارتفاع + "بكسل؛"؛
				divWidth = "الحد الأدنى للعرض:" + هذا.height + "px;";
			}
		}
		var boxloc = "القاع: 10 بكسل؛ اليمين: 10 بكسل"؛
        إذا (هذا.boxLocation == "أعلى اليسار") {
            boxloc = "أعلى: 10 بكسل؛ اليسار: 10 بكسل"؛
        } وإلا إذا (هذا.boxLocation == "أعلى اليمين") {
            boxloc = "أعلى: 10 بكسل؛ يمين: 10 بكسل"؛
        } وإلا إذا (هذا.boxLocation == "bottom-left") {
            boxloc = "الأسفل: 10 بكسل؛ اليسار: 10 بكسل"؛
        } وإلا إذا (هذا.boxLocation == "أسفل اليمين") {
            boxloc = "الأسفل: 10 بكسل؛ اليمين: 10 بكسل"؛
        }
        var boxbarloc = "bottom:2px;right:" + this.offset + "px";
        إذا (هذا.boxLocation == "أعلى اليسار") {
            boxbarloc = "top:2px;left:" + this.offset + "px";
        } وإلا إذا (هذا.boxLocation == "أعلى اليمين") {
            boxbarloc = "top:2px;right:" + this.offset + "px";
        } وإلا إذا (هذا.boxLocation == "bottom-left") {
            boxbarloc = "القاع: 2 بكسل؛ اليسار:" + هذا. الإزاحة + "بكسل"؛
        } وإلا إذا (هذا.boxLocation == "أسفل اليمين") {
            boxbarloc = "القاع: 2 بكسل؛ اليمين:" + هذا. الإزاحة + "بكسل"؛
        }
		var box = document.createElement('div');
		var html =
			"<style>\n"
				+ "." + this.prefix + "box { position:fixed;" + boxloc + ";z-index:52;margin:2px;display:none;" + border + " }\n"
				+ "." + this.prefix + "box:hover { border:1px;border-style:solid;border-color:black; }\n"
				+ "." + this.prefix + "boxmenu { visibility:" + hidden + "; margin-bottom:12px; }\n"
				+ "." + this.prefix + "box:hover ." + this.prefix + "boxmenu { visibility:visible; }\n"
				+ "." + this.prefix + "boxclose, ." + this.prefix + "boxmin, ." + this.prefix + "boxmax { حجم الخط: 22 بكسل؛ الهامش: 2 بكسل؛ الحشو: 0 بكسل؛ زخرفة النص: لا شيء؛ }\n"
				+ (this.forceStyles ? "#" : ".") + "" + this.prefix + "boxbarmax { حجم الخط: 18 بكسل؛ الهامش: 2 بكسل؛ الحشو: 0 بكسل؛ زخرفة النص: لا شيء؛ اللون: أبيض؛ }\n"
				+ "." + this.prefix + "boxclose:hover, ." + this.prefix + "boxmin:hover, ." + this.prefix + "boxmax:hover { color: #fff;background: grey; }\n"
				+ "." + this.prefix + "boxbar { position:fixed;" + boxbarloc + ";z-index:52;margin:0;padding:6px;" + buttonstyle + " }\n"
				+ "." + this.prefix + "boxbar:hover { " + buttonHoverStyle + " }\n"
				+ "." + this.prefix + "no-bubble { margin:4px; padding:8px; border:1px; border-style:solid; border-color:black; background-color:white; }\n"
				+ "." + this.prefix + "no-bubble-plain { margin:4px; padding:8px; border:1px; }\n"
				+ "." + this.prefix + "no-bubble-text { " + responseWidth + "; max-height:100px; overflow:auto; }\n"
				+ "#" + this.prefix + "معلومات الاتصال { " + minHeight + minWidth + " }\n"
				+ "#" + this.prefix + "معلومات الاتصال span { margin-left:4px;margin-top:4px; }\n"
				+ "#" + this.prefix + "معلومات الاتصال المدخلة { الهامش: 4 بكسل؛ حجم الخط: 13 بكسل؛ الارتفاع: 33 بكسل؛ العرض: 90٪؛ الحد: 1 بكسل ثابت # d5d5d5؛ }\n"
				+ "." + this.prefix + "contactconnect { margin:4px;padding:8px;color:white;text-decoration:none;" + buttonstyle + " }\n"
				+ "." + this.prefix + "boxbutton { العرض: 20 بكسل؛ الارتفاع: 20 بكسل؛ الهامش: 4 بكسل؛ }\n"
				+ "." + this.prefix + "menupopup div { position:absolute;margin: -1px 0 0 0;padding: 3px 3px 3px 3px;background: #fff;border-style:solid;border-color:black;border-width:1px;width:180px;max-width:300px;z-index:52;visibility:hidden;opacity:0;transition:visibility 0s linear 0.3s, opacity 0.3s linear; }\n"
				+ "." + this.prefix + "menupopup:hover div { display:inline;visibility:visible;opacity:1;transition-delay:0.5s; }\n"
				+ "a." + this.prefix + "menuitem { text-decoration: none;display: block;color: #585858; }\n"
				+ "a." + this.prefix + "menuitem:hover { color: #fff;background: grey; }\n"
				+ "tr." + this.prefix + "menuitem:hover { الخلفية: رمادية؛ }\n"
				+ "." + this.prefix + "yandex { display:none; }\n"
				+ "." + this.prefix + "powered { margin:4px;color:grey;font-size:10px; }\n"
				+ "img." + this.prefix + "menu { width: 24px;height: 24px;margin: 2px;cursor: pointer;vertical-align: middle; }\n"
				+ "span." + this.prefix + "menu { color: #818181;font-size: 12px; }\n"
				+ "." + this.prefix + "bubble-div { padding-bottom:15px;position:relative; }\n"
				+ "." + this.prefix + "bubble { margin:4px; padding:8px; border:1px; border-style:solid; border-color:black; border-radius:10px; background-color:white; }\n"
				+ "." + this.prefix + "bubble-text { " + responseWidth + "; max-height:100px; overflow:auto; }\n"
				+ "." + this.prefix + "bubble:before { content:''; position:absolute; bottom:0px; left:40px; border-width:20px 0 0 20px; border-style:solid; border-color:black transparent; display:block; width:0;}\n"
				+ "." + this.prefix + "bubble:after { content:''; position:absolute; bottom:3px; left:42px; border-width:18px 0 0 16px; border-style:solid; border-color:white transparent; display:block; width:0;}\n"
				+ (this.forceStyles ? "#" : ".") + this.prefix + "chat { width:100%;min-height:22px; }\n"
				+ "." + this.prefix + "box-input-span { عرض: كتلة؛ تجاوز: مخفي؛ هامش: 4 بكسل؛ حشوة-يمين: 4 بكسل؛ }\n"
				+ "#" + this.prefix + "boxtable { الخلفية: لا شيء؛ الحدود: لا شيء؛ الهامش: 0؛ }\n"
			+ "</style>\n"
			+ "<div id='" + this.prefix + "box' class='" + this.prefix + "box' " + backgroundstyle + ">"
				+ "<div class='" + this.prefix + "boxmenu'>"
					+ (this.backlink ? "<span class='" + this.prefix + "powered'>مدعوم بواسطة <a href='" + SDK.backlinkURL + "' target='_blank'>" + SDK.NAME + "</a></span>" : "")
					+ "<span style='float:right'><a id='" + this.prefix + "boxmin' class='" + this.prefix + "boxmin' href='#'><img src='" + SDK.url + "/images/minimize.png'></a> <a id='"
					+ this.prefix + "boxmax' class='" + this.prefix + "boxmax' href='#'><img src='" + SDK.url + "/images/open.png'> </a></span><br/>"
				+ "</div>";

		إذا (هذا.avatar) {
			html = html
				+ "<div id='" + this.prefix + "avatar-image-div' style='display:none;" + minHeight + minWidth + "'>"
					+ "<img id='" + this.prefix + "avatar' style='" + minHeight + minWidth + "'/>"
				+ "</div>"
				+ "<div id='" + this.prefix + "avatar-video-div' style='display:none;" + divHeight + divWidth + background + "background-repeat: no-repeat;'>"
					+ "<video id='" + this.prefix + "avatar-video' autoplay preload='auto' style='background:transparent;" + minHeight + minWidth + "'>"
						+ "تنسيق الفيديو غير مدعوم بواسطة متصفحك (جرب Chrome)"
					+ "</فيديو>"
				+ "</div>"
				+ "<div id='" + this.prefix + "avatar-canvas-div' style='display:none;" + divHeight + divWidth + "'>"
					+ "<canvas id='" + this.prefix + "avatar-canvas' style='background:transparent;" + minHeight + minWidth + "'>"
						+ "لا يدعم متصفحك القماش (جرب Chrome)"
					+ "</canvas>"
				+ "</div>";
		}
		var urlprefix = this.connection.credentials.url + "/";
		html = html
				+ "<div>"
					+ "<div " + (هذه الفقاعة؟ "class='" + هذه الفقاعة + "bubble-div'" : "") + ">"
					+ "<div class='" + this.prefix + "" + (this.bubble ? "bubble" : (this.background == null ? "no-bubble" : "no-bubble-plain") )
					+ "'><div class='" + this.prefix + (this.bubble ? "bubble-text" : "no-bubble-text" ) + "'>"
						+ "<span id='" + this.prefix + "response'>" + (this.greeting == null ? this.loading : this.greeting) + "</span><br/>"
					+ "</div></div></div>"
					+ "<div><span class='" + this.prefix + "box-input-span'><input id='" + this.prefix + "chat' type='text' class='" + this.prefix + "box-input'/></span></div>";
		html = html
			+ "<div>"
			+ "<span class='" + this.prefix + "menu'>\n"
			+ "<div style='inline-block;position:relative'>\n"
			+ "<span class='" + this.prefix + "menupopup'>"
			+ "<div style='محاذاة النص: يسار؛ أسفل: 36 بكسل'>"
			+ "<الجدول>\n"
			+ "<tr class='" + this.prefix + "menuitem'>"
				+ "<td><a class='" + this.prefix + "menuitem' href='#'><img class='" + this.prefix + "menu' src='" + urlprefix + "images/language.png' title='ترجمة من وإلى اللغة المحددة'>"
				+ " <select id='" + this.prefix + "chooselanguage'>"
					+ "<option value='none'>اختر اللغة</option>"
					+ "<option value='ar'>الإنجليزية</option>"
					+ "<option value='zh'>صيني</option>"
					+ "<option value='es'>الإسبانية</option>"
					+ "<option value='pt'>البرتغالية</option>"
					+ "<option value='de'>الألمانية</option>"
					+ "<option value='fr'>الفرنسية</option>"
					+ "<option value='ja'>اليابانية</option>"
					+ "<option value='ar'>العربية</option>"
					+ "<option value='none'>لا شيء</option>"
					+ "<option value='لا شيء'></option>"
					+ "<option value='af'>الأفريكانية</option>"
					+ "<option value='sq'>الألبانية</option>"
					+ "<option value='hy'>الأرمينية</option>"
					+ "<option value='az'>الأذربيجانية</option>"
					+ "<option value='ba'>بشكير</option>"
					+ "<option value='eu'>الباسكية</option>"
					+ "<option value='be'>البيلاروسية</option>"
					+ "<option value='bn'>البنغالية</option>"
					+ "<option value='bs'>البوسنية</option>"
					+ "<option value='bg'>البلغارية</option>"
					+ "<option value='ca'>الكتالونية</option>"
					+ "<option value='za'>صيني</option>"
					+ "<option value='hr'>الكرواتية</option>"
					+ "<option value='cs'>التشيكية</option>"
					+ "<option value='da'>الدنماركية</option>"
					+ "<option value='nl'>الهولندية</option>"
					+ "<option value='ar'>الإنجليزية</option>"
					+ "<option value='et'>الإستونية</option>"
					+ "<option value='fi'>الفنلندية</option>"
					+ "<option value='fr'>الفرنسية</option>"
					+ "<option value='gl'>الجاليكية</option>"
					+ "<option value='ka'>الجورجية</option>"
					+ "<option value='de'>الألمانية</option>"
					+ "<option value='gu'>الغوجاراتية</option>"
					+ "<option value='ht'>هايتي</option>"
					+ "<option value='he'>العبرية</option>"
					+ "<option value='hi'>الهندية</option>"
					+ "<option value='hu'>المجرية</option>"
					+ "<option value='id'>الإندونيسية</option>"
					+ "<option value='ga'>أيرلندية</option>"
					+ "<option value='it'>الإيطالية</option>"
					+ "<option value='ja'>اليابانية</option>"
					+ "<option value='kn'>الكانادا</option>"
					+ "<option value='kk'>الكازاخستانية</option>"
					+ "<option value='ky'>القيرغيزية</option>"
					+ "<option value='ko'>كورية</option>"
					+ "<option value='la'>اللاتينية</option>"
					+ "<option value='lv'>اللاتفية</option>"
					+ "<option value='lt'>ليتواني</option>"
					+ "<option value='mk'>المقدونية</option>"
					+ "<option value='mg'>الملغاشية</option>"
					+ "<option value='ms'>الماليزية</option>"
					+ "<option value='mt'>المالطية</option>"
					+ "<option value='mn'>المنغولية</option>"
					+ "<option value='no'>النرويجية</option>"
					+ "<option value='fa'>فارسية</option>"
					+ "<option value='pl'>البولندية</option>"
					+ "<option value='pt'>البرتغالية</option>"
					+ "<option value='pa'>البنجابية</option>"
					+ "<option value='ro'>روماني</option>"
					+ "<option value='ru'>الروسية</option>"
					+ "<option value='sr'>الصربية</option>"
					+ "<option value='si'>السنهالية</option>"
					+ "<option value='sk'>السلوفاكية</option>"
					+ "<option value='es'>الإسبانية</option>"
					+ "<option value='sw'>السواحيلية</option>"
					+ "<option value='sv'>السويدية</option>"
					+ "<option value='tl'>التاغالوغية</option>"
					+ "<option value='tg'>الطاجيكية</option>"
					+ "<option value='ta'>التاميل</option>"
					+ "<option value='tt'>التتار</option>"
					+ "<option value='th'>التايلاندية</option>"
					+ "<option value='tr'>تركي</option>"
					+ "<option value='uk'>أوكرانية</option>"
					+ "<option value='ur'>الأردية</option>"
					+ "<option value='uz'>أوزبكي</option>"
					+ "<option value='cy'>الويلزية</option>"
			  	+ "</select>"
			+ "</a></td>"
			+ "</tr>\n";
		إذا (هذا.السماح بالكلام) {
			html = html
				+ "<tr class='" + this.prefix + "menuitem'>"
					+ "<td><a id='" + this.prefix + "boxspeakmenu' class='" + this.prefix + "menuitem' href='#'><img id='" + this.prefix + "boxspeak2' class='" + this.prefix + "menu' src='" + urlprefix + (this.speak ? "images/sound.png": "images/mute.png") +"' title='خطاب'> خطاب</a></td>"
				+ "</tr>\n";
			إذا (SDK.isChrome()) {
				html = html
					+ "<tr class='" + this.prefix + "menuitem'>"
						+ "<td><a id='" + this.prefix + "boxspeakrecognitionmenu' class='" + this.prefix + "menuitem' href='#'>"
								+ "<img id='" + this.prefix + "boxspeakrecognition2' class='" + this.prefix + "menu' src='" + urlprefix + "/images/micoff.png' title='التعرف على الكلام (يجب أن يدعم المتصفح التعرف على الكلام HTML5، مثل Chrome)'> التعرف على الكلام</a>"
						+ "</td>"
					+ "</tr>\n"
			}
		}
		html = html
			+ "</table>\n"
			+ "</div>"
			+ "<img class='" + this.prefix + "boxbutton' src='" + urlprefix + "/images/menu.png'>"
			+ "<img class='" + this.prefix + "boxbutton' src='" + urlprefix + "/images/language.png'>"
			+ "</span>";
		إذا (هذا.السماح بالكلام) {
			html = html
				+ "<a href='#' title='خطاب'><img id='" + this.prefix + "boxspeak' class='" + this.prefix + "boxbutton' src='"
								+ بادئة عنوان URL
								+ (هذا. تحدث ؟ "images/sound.png": "images/mute.png") +"'></a></td>"
					+ (SDK.isChrome() ؟
							("<a href='#' title='التعرف على الكلام'><img id='" + this.prefix + "boxspeakrecognition' class='" + this.prefix + "boxbutton' src='""
									+ بادئة عنوان URL
									+ "images/micoff.png'></a>")
							: "");
		}
		html = html
			+ "</span>"
			+ "</div>"
			+ "</div>"
			+ "<div id='" + this.prefix + "yandex' class='" + this.prefix + "yandex'><span>مدعوم بواسطة <a target='_blank' href='http://translate.yandex.com/'>Yandex.Translate</a></span></div>"
			+ "</div>"
			+ "</div>"
			+ "<div id='" + this.prefix + "boxbar' class='" + this.prefix + "boxbar'>"
				+ "<span><a id='" + this.prefix + "boxbarmax' class='" + this.prefix + "boxbarmax' " + (this.forceStyles ? "style='color:white' " : "") + "href='#'><img src='" + SDK.url + "/images/maximizew.png'> " + this.caption + "</a></span>"
				+ " <a id='" + this.prefix + "boxclose' class='" + this.prefix + "boxclose' href='#'> <img src='" + SDK.url + "/images/closeg.png'></a></span><br/>"
			+ "</div>";
		
		إذا (هذه. معلومات الاتصال الموجهة) {
			html = html
				+ "<div id='" + this.prefix + "contactinfo' class='" + this.prefix + "box' " + backgroundstyle + ">"
					+ "<div class='" + this.prefix + "boxmenu'>"
						+ "<span style='float:right'><a id='" + this.prefix + "contactboxmin' class='" + this.prefix + "boxmin' href='#'><img src='" + SDK.url + "/images/minimize.png'></a>"
					+ "</div>\n"
					+ "<div style='margin:10px'>\n"
						+ "<span>الاسم</span><br/><input id='" + this.prefix + "contactname' type='text' /><br/>\n"
						+ "<span>البريد الإلكتروني</span><br/><input id='" + this.prefix + "contactemail' type='email' /><br/>\n"
						+ "<span>الهاتف</span><br/><input id='" + this.prefix + "contactphone' type='text' /><br/>\n"
						+ "<br/><a id='" + this.prefix + "contactconnect' class='" + this.prefix + "contactconnect' " + (this.forceStyles ? "style='color:white' " : "") + "href='#'>Connect</a>\n"
					+ "<br/><br/></div>\n"
				+ "</div>";
		}
		
		الصندوق الداخليHTML = html؛
		المستند.الجسم.appendChild(الصندوق)؛
		
		var self = هذا؛
		document.getElementById(هذا.prefix + "chat").addEventListener("keypress", function(event) {
			إذا (event.keyCode == 13) {
				self.sendMessage();
				العودة كاذبة؛
			}
		});
		document.getElementById(هذا.prefix + "boxclose").addEventListener("انقر فوق"، دالة() {
			أغلق الصندوق الذاتي();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "boxmin").addEventListener("انقر فوق"، دالة() {
			self.minimizeBox();
			العودة كاذبة؛
		});
		إذا (هذه. معلومات الاتصال الموجهة) {
			document.getElementById(this.prefix + "contactboxmin").addEventListener("click"، function() {
				self.minimizeBox();
				العودة كاذبة؛
			});
			document.getElementById(this.prefix + "contactconnect").addEventListener("click"، function() {
				self.contactConnect();
				العودة كاذبة؛
			});
		}
		document.getElementById(هذا.prefix + "boxmax").addEventListener("انقر فوق"، دالة() {
			self.popup();
			العودة كاذبة؛
		});
		document.getElementById(هذا.prefix + "boxbarmax").addEventListener("انقر فوق"، دالة() {
			self.maximizeBox();
			العودة كاذبة؛
		});
		var langOrig = null؛
		var nativeVoiceOrig = null؛
		var voiceOrig = null؛
		document.getElementById(هذا.prefix + "اختيار اللغة").addEventListener("تغيير"، دالة() {
			إذا (nativeVoiceOrig == null && langOrig == null) {
				langOrig = self.lang؛
				nativeVoiceOrig = self.nativeVoice؛
				voiceOrig = صوت ذاتي؛
			}
			var element = document.getElementById(self.prefix + 'اختيار اللغة');
			self.lang = عنصر.قيمة؛
			إذا (self.lang != "لا شيء") {
				document.getElementById(self.prefix + 'yandex').style.display = "مضمن";
				self.nativeVoice = صحيح؛
				ترجمة ذاتية = صحيح؛
				صوت الذات = لا شيء؛
			} آخر {
				document.getElementById(self.prefix + 'yandex').style.display = "لا شيء";
				ترجمة ذاتية = خطأ؛
				self.lang = langOrig؛
				self.nativeVoice = nativeVoiceOrig؛
				صوت ذاتي = صوت أصلي؛
			}
		});
		إذا (document.getElementById(هذا.prefix + "boxspeak") != null) {
			document.getElementById(هذا.prefix + "boxspeak").addEventListener("انقر فوق"، دالة() {
				تحدث ذاتيًا = !تحدث ذاتيًا؛
				var urlprefix = self.connection.credentials.url + "/";
				إذا (تكلمت بنفسي) {
					المستند.getElementById(self.prefix + "boxspeak").src = urlprefix + "images/sound.png";
					المستند.getElementById(self.prefix + "boxspeak2").src = urlprefix + "images/sound.png";
				} آخر {
					المستند.getElementById(self.prefix + "boxspeak").src = urlprefix + "images/mute.png";
					المستند.getElementById(self.prefix + "boxspeak2").src = urlprefix + "images/mute.png";
				}
				العودة كاذبة؛
			});
			document.getElementById(this.prefix + "boxspeakmenu").addEventListener("انقر فوق"، دالة() {
				تحدث ذاتيًا = !تحدث ذاتيًا؛
				var urlprefix = self.connection.credentials.url + "/";
				إذا (تكلمت بنفسي) {
					المستند.getElementById(self.prefix + "boxspeak").src = urlprefix + "images/sound.png";
					المستند.getElementById(self.prefix + "boxspeak2").src = urlprefix + "images/sound.png";
				} آخر {
					المستند.getElementById(self.prefix + "boxspeak").src = urlprefix + "images/mute.png";
					المستند.getElementById(self.prefix + "boxspeak2").src = urlprefix + "images/mute.png";
				}
				العودة كاذبة؛
			});
		}
		إذا (document.getElementById(هذا.prefix + "boxspeakrecognition") != null) {
			SDK.registerSpeechRecognition(document.getElementById(self.prefix + 'chat')، function() {
				self.sendMessage();
			});
			document.getElementById(هذا.prefix + "boxspeakrecognition").addEventListener("انقر فوق"، دالة() {
				الاستماع الذاتي = !الاستماع الذاتي؛
				إذا (استمع ذاتيًا) {
					SDK.startSpeechRecognition();
					المستند.getElementById(self.prefix + 'boxspeakrecognition').src = urlprefix + "images/mic.png";
					المستند.getElementById(self.prefix + 'boxspeakrecognition2').src = urlprefix + "images/mic.png";
				} آخر {
					SDK.stopSpeechRecognition();
					document.getElementById(self.prefix + 'boxspeakrecognition').src = urlprefix + "images/micoff.png";
					document.getElementById(self.prefix + 'boxspeakrecognition2').src = urlprefix + "images/micoff.png";
				}
			});
			document.getElementById(this.prefix + "boxspeakrecognitionmenu").addEventListener("click", function() {
				self.listen = !self.listen;
				if (self.listen) {
					SDK.startSpeechRecognition();
					document.getElementById(self.prefix + 'boxspeakrecognition').src = urlprefix + "images/mic.png";
					document.getElementById(self.prefix + 'boxspeakrecognition2').src = urlprefix + "images/mic.png";
				} else {
					SDK.stopSpeechRecognition();
					document.getElementById(self.prefix + 'boxspeakrecognition').src = urlprefix + "images/micoff.png";
					document.getElementById(self.prefix + 'boxspeakrecognition2').src = urlprefix + "images/micoff.png";
				}
			});
		}
	}
	
	/**
	 * Create a live chat bar beside the bot bar.
	 */
	this.createLiveChatBox = function(channel, label, position) {
		var box = document.createElement('div');
		var buttonstyle = "";
		if (this.color != null) {
			buttonstyle = "background-color:" + this.color + ";";
		}
		var buttonHoverStyle = "";
		if (this.hoverColor != null) {
			buttonHoverStyle = "background-color:" + this.hoverColor + ";";
		}
		if (label == null) {
			label = "Live Chat";
		}
		if (position == null) {
			position = (this.caption.length + label.length) * 8;
			position = "right:" + position + "px";
		}
		var html =
			"<style>\n"
				+ "." + this.prefix + "livechatboxbar { position:fixed;bottom:2px;" + position + ";z-index:52;margin:0;padding:6px;" + buttonstyle + " }\n"
				+ "." + this.prefix + "livechatboxbar:hover { " + buttonHoverStyle + " }\n"
				+ (this.forceStyles ? "#" : ".") + this.prefix + "livechatboxmax { color:white;font-size:18px;margin:2px;padding:0px;text-decoration:none; }\n"
			+ "</style>\n"
			+ "<div id='" + this.prefix + "livechatboxbar' class='" + this.prefix + "livechatboxbar'>"
			+ "<span><a id='" + this.prefix + "livechatboxmax' class='" + this.prefix + "livechatboxmax' href='#'>" + label + "</a></span>"
			+ "</div>";
		
		box.innerHTML = html;
		document.body.appendChild(box);
		
		document.getElementById(this.prefix + "livechatboxmax").addEventListener("click", function() {
			SDK.popupwindow(SDK.url + '/livechat?id=' + channel + '&embedded&chat','child', 700, 520);
			return false;
		});
	}
	
	/**
	 * Minimize the embedding div in the current webpage.
	 */
	this.minimizeBox = function() {
		if (this.promptContactInfo) {
			document.getElementById(this.prefix + "contactinfo").style.display = 'none';
		}
		document.getElementById(this.prefix + "box").style.display = 'none';
		document.getElementById(this.prefix + "boxbar").style.display = 'inline';
		var livechatbot = document.getElementById(this.prefix + "livechatboxbar");
		if (livechatbot != null) {
			livechatbot.style.display = 'inline';
		}
		this.exit();
		return false;		
	}

	/**
	 * Check contact info and connect.
	 */
	this.contactConnect = function() {
		this.hasContactInfo = true;
		this.contactName = document.getElementById(this.prefix + "contactname").value;
		var ok = true;
		if (this.contactName != null && this.contactName == "") {
			ok = false;
			document.getElementById(this.prefix + "contactname").style.borderColor = "red";
			document.getElementById(this.prefix + "contactname").placeholder = "Enter name";
		}
		this.contactEmail = document.getElementById(this.prefix + "contactemail").value;
		if (this.contactEmail != null && this.contactEmail.indexOf("@") == -1) {
			ok = false;
			document.getElementById(this.prefix + "contactemail").style.borderColor = "red";
			document.getElementById(this.prefix + "contactemail").placeholder = "Enter valid email";
		}
		this.contactPhone = document.getElementById(this.prefix + "contactphone").value;
		this.contactInfo = this.contactName + " " + this.contactEmail + " " + this.contactPhone;
		if (ok) {
			this.maximizeBox();
		}
	}
	
	/**
	 * Maximize the embedding div in the current webpage.
	 */
	this.maximizeBox = function() {
		if (this.promptContactInfo && !this.hasContactInfo) {
			document.getElementById(this.prefix + "contactinfo").style.display = 'inline';
			document.getElementById(this.prefix + "boxbar").style.display = 'none';
			document.getElementById(this.prefix + "box").style.display = 'none';
			var livechatbot = document.getElementById(this.prefix + "livechatboxbar");
			if (livechatbot != null) {
				livechatbot.style.display = 'none';
			}
		} else {
			if (this.promptContactInfo) {
				document.getElementById(this.prefix + "contactinfo").style.display = 'none';
			}
			document.getElementById(this.prefix + "boxbar").style.display = 'none';
			document.getElementById(this.prefix + "box").style.display = 'inline';
			var livechatbot = document.getElementById(this.prefix + "livechatboxbar");
			if (livechatbot != null) {
				livechatbot.style.display = 'none';
			}
			this.greet();
		}
		return false;		
	}
	
	/**
	 * Close the embedding div in the current webpage.
	 */
	this.closeBox = function() {
		if (this.promptContactInfo) {
			document.getElementById(this.prefix + "contactinfo").style.display = 'none';
		}
		document.getElementById(this.prefix + "boxbar").style.display = 'none';
		document.getElementById(this.prefix + "box").style.display = 'none';
		var livechatbot = document.getElementById(this.prefix + "livechatboxbar");
		if (livechatbot != null) {
			livechatbot.style.display = 'none';
		}
		this.exit();
		return false;		
	}
	
	/**
	 * Create a popup window chat session with the bot.
	 */
	this.popup = function() {
		var box = document.getElementById(this.prefix + "box");
		if (box != null) {
			box.style.display = 'none';
		}
		var speech = this.speak;
		if (!this.allowSpeech) {
			speech = "disable";
		}
		var height = 520;
		if (!this.avatar) {
			height = 220;
		}
		if (this.popupURL != null) {
			var popupURL = this.popupURL;
			if (popupURL.indexOf("chat?") != -1 && this.contactInfo != null && this.contactInfo != "") {
				popupURL = popupURL + "&info=" + encodeURI(this.contactInfo);
			}
			SDK.popupwindow(popupURL, 'child', 700, height);
		} else {			
			var form = document.createElement("form");
            form.setAttribute("method", "post");
            form.setAttribute("action", SDK.url + "/chat");
            form.setAttribute("target", 'child');
 
            var input = document.createElement('input');
            input.type = 'hidden';
            input.name = "id";
            input.value = this.instance;
            form.appendChild(input);
 
            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "embedded";
            input.value = "embedded";
            form.appendChild(input);
 
            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "speak";
            input.value = speech;
            form.appendChild(input);
 
            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "avatar";
            input.value = this.avatar;
            form.appendChild(input);
 
            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "info";
            input.value = this.contactInfo;
            form.appendChild(input);
 
            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "application";
            input.value = this.connection.credentials.applicationId;
            form.appendChild(input);
            
            document.body.appendChild(form);
            
			SDK.popupwindow('','child', 700, height);
			
			form.submit();
            document.body.removeChild(form);
		}
		this.minimizeBox();
		return false;
	}
	
	/**
	 * A chat message was received from the bot.
	 */
	this.response = function(user, message) {
		document.getElementById(this.prefix + 'response').innerHTML = SDK.linkURLs(message);
		this.message(user, message);
		if (this.focus) {
			document.getElementById(this.prefix + 'chat').focus();
		}
		if (this.onresponse != null) {
			this.onresponse(message);
		}
	}
	
	/**
	 * A chat message was received from the bot.
	 */
	this.message = function(user, message) {
		var speaker = user;
		var scroller = document.getElementById(this.prefix + 'scroller');
		var chatconsole = document.getElementById(this.prefix + 'console');
		if (scroller == null || chatconsole == null) {
			return;
		}
		var tr = document.createElement('tr');
		var td = document.createElement('td');
		var td2 = document.createElement('td');
		var span2 = document.createElement('span');
		var chatClass = 'chat-1';
		if (this.switchText) {
			chatClass = 'chat-2';
		}
		if (this.botThumb == null || this.userThumb == null) {
			var span = document.createElement('span');
			span.className = chatClass;
			span.innerHTML = speaker;
			td.appendChild(span);
		} else {
			var img = document.createElement('img');
			img.className = 'chat-user';
			img.setAttribute('alt', speaker);
			إذا (المستخدم == هذا.اسم المستخدم) {
				img.setAttribute('src', this.userThumb);
			} آخر {
				img.setAttribute('src', this.botThumb);
			}
			td.appendChild(img);			
		}
		span2.className = chatClass؛
		span2.innerHTML = SDK.linkURLs(الرسالة)؛
		td.className = 'مستخدم الدردشة';
		td.setAttribute('nowrap', 'nowrap');
		td2.className = chatClass؛
		td2.setAttribute('محاذاة', 'يسار');
		td2.setAttribute('العرض', '100%');
		chatconsole.appendChild(tr);
		tr.appendChild(td);
		tr.appendChild(td2);
		td2.appendChild(span2);
		هذا.switchText = !هذا.switchText؛
		بينما (chatconsole.childNodes.length > 500) {
			chatconsole.removeChild(chatconsole.firstChild);
		}
		scroller.scrollTop = scroller.scrollHeight؛
	};

	/**
	 * تحديث صورة/فيديو/صوت رمز البوت من استجابة الدردشة.
	 */
	هذا.updateAvatar = دالة (رسالة الاستجابة) {
		var urlprefix = this.connection.credentials.url + "/";
		SDK.updateAvatar(رسالة الاستجابة، هذا. تحدث، بادئة عنوان url، هذه. بادئة، لا شيء، لا شيء، هذا. الصوت الأصلي، هذه. اللغة، هذا. اسم الصوت الأصلي)؛
	};

	هذا.toggleSpeak = دالة () {
		هذا.تكلم = !هذا.تكلم؛
	}
	
	/**
	 * تهيئة مستمع الروبوت.
	 */
	هذا.بدء = دالة () {
		إذا (هذا.prefix == "" و هذا.elementPrefix != null) {
			هذا.البادئة = هذا.العنصرالبادئة؛
		}
		var self = هذا؛
		هذا.خطأ الاتصال = دالة (الرسالة) {
			self.response("خطأ"، رسالة);
		}
		إذا (هذا.avatar) {
			var config = new ChatConfig();
			config.instance = هذا.instance؛
			إذا (هذا.ترجم) {
				config.language = this.lang؛
			}
			إذا (هذا التنسيق != null) {
				config.avatarFormat = هذا التنسيق؛
			}
			إذا (هذا.hd != null) {
				config.avatarHD = this.hd؛
			}
			هذا.الاتصال.initChat(التكوين، وظيفة(رسالة الاستجابة) {
				إذا (هذه المحادثة == لا شيء) {
					self.updateAvatar(رسالة الاستجابة)؛
				}
			});
		}
	}
	
	/**
	 * أرسل رسالة فارغة إلى الروبوت للسماح له بتحية المستخدم.
	 * سيؤدي هذا إلى جعل الروبوت يستجيب بأي تحية محددة لديه.
	 */
	هذه.تحية = دالة () {
		هذا.ابدأ();
		var chat = new ChatConfig();
		معلومات الدردشة = هذه معلومات الاتصال؛
		chat.instance = هذا.instance؛
		إذا (هذا.ترجم) {
			لغة الدردشة = هذه اللغة؛
		}
		إذا (هذا.avatarId != null) {
			chat.avatar = هذا.avatarId؛
		}
		إذا (هذا.hd != null) {
			chat.avatarHD = هذا.hd؛
		} وإلا إذا ((هذا العرض != لا شيء و هذا العرض > 400) || (هذا الارتفاع != لا شيء و هذا الارتفاع > 400)) {
			chat.avatarHD = صحيح؛
		}
		إذا (هذا التنسيق != null) {
			chat.avatarFormat = هذا التنسيق؛
		}
		إذا (هذا.nativeVoice && SDK.speechSynthesis) {
			الدردشة.التحدث = خطأ؛
		} آخر {
			الدردشة.التحدث = هذا.التحدث؛
		}
		var self = هذا؛
		إذا (هذا.خارجي) {
			هذه.externalChat(الدردشة)؛
		} آخر {
			هذا.الاتصال.الدردشة(الدردشة، وظيفة(رسالة الاستجابة) {
				محادثة ذاتية = رسالة استجابة. محادثة؛
				self.updateAvatar(رسالة الاستجابة)؛
				if (responseMessage.message != null && responseMessage.message != "") {
					self.response(self.instanceName, responseMessage.message);
				} else if (self.greeting == null) {
					document.getElementById(self.prefix + 'response').innerHTML = "Hi";
				}
			});
		}
		return false;
	};
	
	/**
	 * Send the current text from the chat input as a message to the bot, and process the response.
	 */
	this.sendMessage = function() {
		var message = document.getElementById(this.prefix + 'chat').value;
		if (message != '') {
			this.message(this.userName, message);
			var chat = new ChatConfig();
			chat.message = message;
			chat.instance = this.instance;
			if (this.translate) {
				chat.language = this.lang;
			}
			if (this.avatarId != null) {
				chat.avatar = this.avatarId;
			}
			if (this.hd != null) {
				chat.avatarHD = this.hd;
			} else if ((this.width != null && this.width > 400) || (this.height != null && this.height > 400)) {
				chat.avatarHD = true;
			}
			if (this.format != null) {
				chat.avatarFormat = this.format;
			}
			if (this.nativeVoice && SDK.speechSynthesis) {
				chat.speak = false;
			} else {
				chat.speak = this.speak;
			}
			chat.conversation = this.conversation;
			var correction = document.getElementById(this.prefix + 'correction');
			if (correction != null && correction.checked) {
				chat.correction = true;
				correction.checked = false;
			}
			var learning = document.getElementById(this.prefix + 'learning');
			if (learning != null && learning.style.display != "none") {
				chat.learn = learning.checked;
			}
			var debug = document.getElementById(this.prefix + 'debug');
			if (debug != null && debug.checked) {
				chat.debug = true;
				var debugLevel = document.getElementById(this.prefix + 'debugLevel');
				if (debugLevel != null) {
					chat.debugLevel = debugLevel.value;
				}
			}
			var offensive = document.getElementById(this.prefix + 'offensive');
			if (offensive != null && offensive.checked) {
				chat.offensive = true;
				offensive.checked = false;
			}
			var emote = document.getElementById(this.prefix + 'emote');
			if (emote != null && emote.value != null && emote.value != "" && emote.value != "NONE") {
				chat.emote = emote.value.toUpperCase();
				emote.value = "NONE";
			}
			var action = document.getElementById(this.prefix + 'action');
			if (action != null && action.value != null && action.value != "") {
				chat.action = action.value;
				action.value = "";
			}
			var self = this;
			document.getElementById(this.prefix + 'response').innerHTML = '<i>thinking</i>';
			document.getElementById(this.prefix + 'chat').value = '';
			if (this.external) {
				this.externalChat(chat);
			} else {
				this.connection.chat(chat, function(responseMessage) {
					self.conversation = responseMessage.conversation;
					self.response(self.instanceName, responseMessage.message);
					self.updateAvatar(responseMessage);
					var log = document.getElementById(self.prefix + 'log');
					var logText = responseMessage.log;
					if (log != null) {
						if (logText != null) {
							log.style.display = "inline";
							log.innerHTML = logText;
						} else {
							log.innerHTML = "";
						}
					}
				});
			}
		}
		return false;
	};
	
	/**
	 * Send an external API chat request.
	 */
	this.externalChat = function(chat) {
		var url = this.apiURL;
		if (chat.message == null) {
			url = url.replace(":message", "");			
		} else {
			url = url.replace(":message", encodeURIComponent(chat.message));
		}
		if (chat.conversation == null) {
			url = url.replace(":conversation", "");
		} else {
			url = url.replace(":conversation", encodeURIComponent(chat.conversation));			
		}
		if (chat.speak) {
			url = url.replace(":speak", "true");
		} else {
			url = url.replace(":speak", "");			
		}
		var self = this;
		this.connection.GET(url, function(xml) {
			if (xml == null) {
				return null;
			}
			var responseMessage = new ChatResponse();
			responseMessage.parseXML(xml);
			self.conversation = responseMessage.conversation;
			self.response(self.instanceName, responseMessage.message);
			var urlprefix = self.apiURL.substring(0, self.apiURL.indexOf("/rest/api/form-chat")) + "/";
			SDK.updateAvatar(responseMessage, self.speak, urlprefix, self.prefix, null, null, self.nativeVoice, self.lang, self.nativeVoiceName);
			var log = document.getElementById(self.prefix + 'log');
			var logText = responseMessage.log;
			if (log != null) {
				if (logText != null) {
					log.innerHTML = logText;
				} else {
					log.innerHTML = "";
				}
			}
		});
	}

	/**
	 * Exit the conversation.
	 */
	this.exit = function() {
		if (this.conversation == null || this.external) {
			return false;
		}
		var chat = new ChatConfig();
		chat.disconnect = true;
		chat.instance = this.instance;
		chat.conversation = this.conversation;
		var self = this;
		this.connection.chat(chat, function(responseMessage) {
			self.conversation = null;
		});
		return false;
	};

	/**
	 * Clear the chat console.
	 */
	this.clear = function() {
		document.getElementById(this.prefix + 'response').innerHTML = '';
		var console = document.getElementById(this.prefix + 'console');
		if (console != null) {
			console.innerHTML = '';
		}
		return false;
	};

	this.resizeAvatar = function () {
		var avatar = document.getElementById(this.prefix + "avatar");
		var avatarDiv = document.getElementById(this.prefix + "avatar-image-div");
		var avatarVideo = document.getElementById(this.prefix + "avatar-video");
		var avatarVideoDiv = document.getElementById(this.prefix + "avatar-video-div");
		var avatarCanvas = document.getElementById(this.prefix + "avatar-canvas");
		var avatarCanvasDiv = document.getElementById(this.prefix + "avatar-canvas-div");
		var scroller = document.getElementById(this.prefix + "scroller");
		if (!this.big) {
			this.hd = true;
			if (avatar != null) {
				avatar.className = "avatar-big";
			}
			if (avatarVideo != null) {
				avatarVideo.className = "avatar-video-big";
			}
			if (avatarVideoDiv != null) {
				avatarVideoDiv.className = "avatar-video-div-big";
			}
			if (avatarCanvas != null) {
				avatarCanvas.className = "avatar-canvas-big";
			}
			if (avatarCanvasDiv != null) {
				avatarCanvasDiv.className = "avatar-canvas-div-big";
			}
			if (scroller != null) {
				scroller.style.display = "none";
			}
			this.big = true;
		} else {
			this.hd = false;
			if (avatar != null) {
				avatar.className = "avatar";
			}
			if (avatarVideo != null) {
				avatarVideo.className = "avatar-video";
			}
			if (avatarVideoDiv != null) {
				avatarVideoDiv.className = "avatar-video-div";
			}
			if (avatarCanvas != null) {
				avatarCanvas.className = "avatar-canvas";
			}
			if (avatarCanvasDiv != null) {
				avatarCanvasDiv.className = "avatar-canvas-div";
			}
			if (scroller != null) {
				scroller.style.display = "inline-block";
			}
			this.big = false;
		}
		if (window.onresize != null) {
			setTimeout(window.onresize(), 100);
		}
		return false;
	}
}

/**
 * The WebAvatar provides access to an avatar and binds it to elements in an HTML document.
 * It lets you use a bot avatar without having a bot.  You can tell the avatar what to say, and what actions and poses to display.
 * The HTML document requires the following elements:
 * <ul>
 * <li> avatar - img element for the avatar
 * <li> avatar-image-div - div element for the avatar's image
 * <li> avatar-video - video element for the avatar's video
 * <li> avatar-video-div - div element for the avatar's video
 * </ul>
 * If a prefix is set, these id will be prefixed by the prefix.
 * Or you can call createBox() to have the WebAvatar create its own components in the current page.
 * @class
 */
function WebAvatar() {
	/** Enable or disable speech. */
	this.speak = true;
	/** Configure if the browser's native voice TTS should be used. */
	this.nativeVoice = false;
	/** Set the language for the native voice. */
	this.lang = null;
	/** Set the voice for the native voice. */
	this.nativeVoiceName = null;
	/** An SDK connection object must be set. */
	this.connection = null;
	/** The id or name of the avatar object to use. */
	this.avatar = null;
	/** The name of the voice to use. */
	this.voice = null;
	/** Allow the background color to be set. */
	this.background = null;
	/** Avatar image/video width. */
	this.width = 300;
	/** Avatar image/video height. */
	this.height = null;
	/** Only apply the background color if not Chrome. */
	this.backgroundIfNotChrome = false;
	/** An optional close event. */
	this.onclose = null;
	/** Return if the avatar box is in a closed state. */
	this.closed = true;
	/** Element id and class prefix. Can be used to have multiple avatars in the same page, or avoid naming collisions. */
	this.prefix = "avatar-";
	/** Store list of messages to output. */
	this.messages = null;
	/** Function to invoke when processing all messages is complete. */
	this.ended = null;
	/** Set if the avatar should request HD (high def) video/images. */
	this.hd = null;
	/** Set if the avatar should request a specific video or image format. */
	this.format = null;
	
	/**
	 * Create an embedding bar and div in the current webpage.
	 */
	this.createBox = function() {
		if (this.prefix == "" && this.elementPrefix != null) {
			this.prefix = this.elementPrefix;
		}
		var backgroundstyle = "";
		var hidden = "hidden";
		var border = "";
		if ((this.background != null) && (!this.backgroundIfNotChrome || !SDK.isChrome())) {
			backgroundstyle = " style='background-color:" + this.background + "'";
			hidden = "visible";
			border = "border:1px;border-style:solid;border-color:black;";
		}
		var box = document.createElement('div');
		var minWidth = "";
		var minHeight = "";
		var divWidth = "";
		var divHeight = "";
		var background = "";
		if (this.width != null) {
			minWidth = "width:" + this.width + "px;";
			background = "background-size:" + this.width + "px;";
			divWidth = minWidth;
			divHeight = "min-height:" + this.width + "px;";
		}
		if (this.height != null) {
			minHeight = "height:" + this.height + "px;";
			divHeight = minHeight;
			if (this.width != null) {
				background = "background-size:" + this.width + "px " + this.height + "px;";
			} else {
				background = "background-size: auto " + this.height + "px;";
				divWidth = "min-width:" + this.height + "px;";
			}
		}
		var html =
			"<style>\n"
				+ "." + this.prefix + "avatarbox { position:fixed;bottom:10px;left:10px;z-index:52;margin:2px;" + border + " }\n"
				+ "." + this.prefix + "avatarbox:hover { border:1px;border-style:solid;border-color:black; }\n"
				+ "." + this.prefix + "avatarbox ." + this.prefix + "avatarboxmenu { visibility:" + hidden + "; }\n"
				+ "." + this.prefix + "avatarbox:hover ." + this.prefix + "avatarboxmenu { visibility:visible; }\n"
				+ "img." + this.prefix + "avatarboxclose { margin:4px }\n"
				+ "#" + this.prefix + "avatarboxclose { margin:0px;font-size:26px; }\n"
				+ "#" + this.prefix + "avatarboxclose:hover { color: #fff;background: grey; }\n"
			+ "</style>\n"
			+ "<div id='" + this.prefix + "avatarbox' class='" + this.prefix + "avatarbox' " + backgroundstyle + ">"
				+ "<div class='" + this.prefix + "avatarboxmenu'>"
					+ "<span style='float:right'><a id='" + this.prefix + "avatarboxclose' href='#'><img class='" + this.prefix + "avatarboxclose' src='" + SDK.url + "/images/closeg.png'></a></span><br/>"
				+ "</div>"
				+ "<div id='" + this.prefix + "avatar-image-div' style='display:none;" + minWidth + minHeight + "'>"
					+ "<img id='" + this.prefix + "avatar' style='" + minWidth + minHeight + "'/>"
				+ "</div>"
				+ "<div id='" + this.prefix + "avatar-video-div' style='display:none;" + divWidth + divHeight + background + "background-repeat: no-repeat;'>"
					+ "<video id='" + this.prefix + "avatar-video' autoplay preload='auto' style='background:transparent;" + minWidth + minHeight + "'>"
						+ "Video format not supported by your browser (try Chrome)"
					+ "</video>"
				+ "</div>"
				+ "<div id='" + this.prefix + "avatar-canvas-div' style='display:none;" + divWidth + divHeight + "'>"
					+ "<canvas id='" + this.prefix + "avatar-canvas' style='background:transparent;" + minWidth + minHeight + "'>"
						+ "Canvas not supported by your browser (try Chrome)"
					+ "</canvas>"
				+ "</div>"				
			+ "</div>";
		
		box.innerHTML = html;
		document.body.appendChild(box);
		
		var self = this;
		document.getElementById(this.prefix + "avatarboxclose").addEventListener("click", function() {
			self.closeBox();
			return false;
		});
		this.closed = false;
	}
	
	/**
	 * Open the embedding div in the current webpage.
	 */
	this.openBox = function() {
		document.getElementById(this.prefix + "avatarbox").style.display = 'inline';
		this.speak = true;
		this.closed = false;
		return false;		
	}
	
	/**
	 * Close the embedding div in the current webpage.
	 */
	this.closeBox = function() {
		document.getElementById(this.prefix + "avatarbox").style.display = 'none';
		this.speak = false;
		if (this.onclose != null) {
			this.onclose();
		}
		this.closed = true;
		return false;		
	}

	/**
	 * Update the avatar's image/video/audio from the message response.
	 */
	this.updateAvatar = function(responseMessage, afterFunction) {
		var urlprefix = this.connection.credentials.url + "/";
		SDK.updateAvatar(responseMessage, this.speak, urlprefix, this.prefix, false, afterFunction, this.nativeVoice, this.lang, this.nativeVoiceName);
	};
	
	/**
	 * Add the message to the avatars message queue.
	 * The messages will be spoken when processMessages() is called.
	 */
	this.addMessage = function(message, emote, action, pose) {
		var config = new AvatarMessage();
		config.message = message;
		config.avatar = this.avatar;
		if (this.hd != null) {
			config.hd = this.hd;
		} else if ((this.width != null && this.width > 400) || (this.height != null && this.height > 400)) {
			config.hd = true;
		}
		if (this.format != null) {
			config.format = this.format;
		}
		if (this.nativeVoice && SDK.speechSynthesis) {
			config.speak = false;
		} else {
			config.speak = this.speak;
			config.voice = this.voice;
		}
		config.emote = emote;
		config.action = action;
		config.pose = pose;
		if (this.messages == null) {
			this.messages = [];
		}
		this.messages[this.messages.length] = config;
		return false;
	};
	
	/**
	 * Add the message to the avatars message queue.
	 * The messages will be spoken when runMessages() is called.
	 */
	this.processMessages = function(pause) {
		if (this.messages == null || this.messages.length == 0) {
			if (this.ended != null) {
				this.ended();
			}
			return false;
		}
		if (pause == null) {
			pause = 500;
		}
		var self = this;
		var message = this.messages[0];
		this.messages = this.messages.splice(1, this.messages.length);
		this.connection.avatarMessage(message, function(responseMessage) {
			self.updateAvatar(responseMessage, function() {
				setTimeout(function() {
					self.processMessages(pause);
				}, pause);
			});
		});
		return false;
	}
	
	/**
	 * Have the avatar speak the message with voice and animation.
	 * The function will be called at the end of the speech.
	 */
	this.message = function(message, emote, action, pose, afterFunction) {
		var config = new AvatarMessage();
		config.message = message;
		config.avatar = this.avatar;
		if (this.nativeVoice && SDK.speechSynthesis) {
			config.speak = false;
		} else {
			config.speak = this.speak;
			config.voice = this.voice;
		}
		config.emote = emote;
		config.action = action;
		config.pose = pose;
		var self = this;
		this.connection.avatarMessage(config, function(responseMessage) {
			self.updateAvatar(responseMessage, afterFunction);
		});
		return false;
	};
}

/**
 * Connection class for a Live Chat, or chatroom connection.
 * A live chat connection is different than an SDKConnection as it is asynchronous,
 * and uses web sockets for communication.
 * @class
 * @property channel
 * @property user
 * @property credentials
 * @property listener
 * @property keepAlive
 * @property onMediaStream
 * @property onMediaStreamEnded
 * @property nick
 * @property channelToken
 * @property onNewChannel
 * @property nick
 */
function LiveChatConnection() {
	this.channel = null;
	this.user = null;
	this.contactInfo = null;
	this.credentials = new Credentials();
	this.socket = null;
	this.listener = null;
	this.keepAlive = false;
	this.keepAliveInterval = null;
	this.mediaConnection = null;
	this.onMediaStream = null;
	this.onMediaStreamEnded = null;
	this.nick = null;
	this.channelToken = null;
	this.onNewChannel = null;
	this.onMessageCallbacks = {};
		
	/**
	 * Connect to the live chat server channel.
	 * Validate the user credentials.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 */
	this.connect = function(channel, user) {
		if (this.credentials == null) {
			throw "Mising credentials";
		}
		this.channel = channel;
		this.user = user;
		if (this.nick == null && this.user != null) {
			this.nick = this.user.user;
		}
		var host = null;
		if (SDK.scheme == "https") {
			host = "wss://" + this.credentials.host + this.credentials.app + "/live/chat";
		} else {
			host = "ws://" + this.credentials.host + this.credentials.app + "/live/chat";			
		}
		if ('WebSocket' in window) {
			this.socket = new WebSocket(host);
		} else if ('MozWebSocket' in window) {
			this.socket = new MozWebSocket(host);
		} else {
			throw 'Error: WebSocket is not supported by this browser.';
		}
		
		this.listener.connection = this;
		var self = this;
		
		this.socket.onopen = function () {
			if (self.channel != null) {
				var appId = self.credentials.applicationId;
				if (appId == null) {
					appId = '';
				}
				var connectString = "connect " + self.channel.id;
				if (self.user == null) {
					connectString = connectString + " " + appId;
				} else if (user.token == null) {
					connectString = connectString + " " + self.user.user + " " + self.user.password + " " + appId;						
				} else {
					connectString = connectString + " " + self.user.user + " " + self.user.token + " " + appId;						
				}
				if (self.contactInfo != null) {
					connectString = connectString + " @info " + self.contactInfo;
				}
				self.socket.send(connectString);
			}
			self.setKeepAlive(this.keepAlive);
		};
		
		this.socket.onclose = function () {
			self.listener.message("Info: Closed");
			self.listener.closed();
			self.disconnectMedia();
		};
		
		this.socket.onmessage = function (message) {
	    	user = "";
	    	data = message.data;
	    	text = data;
	    	index = text.indexOf(':');
	    	if (index != -1) {
	    		user = text.substring(0, index);
	    		data = text.substring(index + 2, text.length);
	    	}
			if (user == "Media") {
			    data = JSON.parse(data);

			    if (data.sender == self.nick) {
			    	return;
			    }
			    if (data.channel != self.channelToken) {
			    	return;
			    }

			    if (self.onMessageCallbacks[data.channel]) {
			    	self.onMessageCallbacks[data.channel](data.message);
			    };
			    return;
			}
			if (user == "Online-xml") {
				self.listener.updateUsersXML(data);
				return;
			}
			if (user == "Online") {
				self.listener.updateUsers(data);
				return;
			}
			if (user == "Channel") {
				self.channelToken = data;
				if (self.onNewChannel != null) {
					self.onNewChannel(data);
				}
				return;
			}
			if (user == "Nick") {
				if (self.nick == null) {
					self.nick = data;
				}
				return;
			}
			
			if (self.keepAlive && user == "Info" && text.contains("pong")) {
				return;
			}
			if (user == "Info") {
				self.listener.info(text);
				return;
			}
			if (user == "Error") {
				self.listener.error(text);
				return;
			}
			self.listener.message(text);
		};
	};

	/**
	 * Connect to the active channels media feed (video, audio).
	 */
	this.connectMedia = function(mediaChannel, shareAudio, shareVideo) {
		if (this.mediaConnection != null) {
			this.mediaConnection.leave();
		}
		this.mediaConnection = new RTCMultiConnection(mediaChannel);
		var self = this;
		var open = false;
		this.mediaConnection.session = {
		    audio: shareAudio,
		    video: shareVideo
		};
		/*this.mediaConnection.mediaConstraints.audio = {
		    mandatory: {},
		    optional: [{
		        googEchoCancellation: true,
		        googAutoGainControl: true,
		        googNoiseSuppression: true,
		        googHighpassFilter: true,
		        googTypingNoiseDetection: true,
		        googAudioMirroring: true
		    }]
		};*/
		/*this.mediaConnection.privileges = {
		    canStopRemoteStream: true,
		    canMuteRemoteStream: true
		};*/

		this.mediaConnection.openSignalingChannel = function (config) {
		    var channel = config.channel || this.channel;
		    self.onMessageCallbacks[channel] = config.onmessage;

		    if (config.onopen) {
		    	setTimeout(config.onopen, 1000);
		    }

		    // directly returning socket object using "return" statement
		    return {
		        send: function (message) {
		            self.socket.send("Media: " + JSON.stringify({
		                sender: self.nick,
		                channel: channel,
		                message: message
		            }));
		        },
		        channel: channel
		    };
		};
		this.mediaConnection.onstream = function(stream) {
			open = true;
			if (self.onMediaStream != null) {
				self.onMediaStream(stream);
			}
		};
		this.mediaConnection.onstreamended = function(stream) {
			if (self.onMediaStreamEnded != null) {
				self.onMediaStreamEnded(stream);
			}
		};
		this.mediaConnection.onNewSession = function(session) {
		    session.join({
			    audio: shareAudio,
			    video: shareVideo
			});
		};
		if (this.nick != null) {
			this.mediaConnection.userid = this.nick;
		}
		//connection.log = false;
		this.mediaConnection.onerror = function(error) {
			SDK.error(error);
		}
		this.mediaConnection.onMediaError = function(error) {
			SDK.error(error);
		}
		this.mediaConnection.connect();
	    setTimeout(function() {
	    	if (!open) {
	    		self.mediaConnection.open("room");
	    	}
	    }, 5000);
	}
	
	/**
	 * Disconnect from the active channels media feed (video, audio).
	 */
	this.disconnectMedia = function() {
		if (this.mediaConnection != null) {
			this.mediaConnection.leave();
			this.mediaConnection = null;
		}
	}
	
	/**
	 * Reset the media feed (audio, video).
	 */
	this.resetMedia = function(shareAudio, shareVideo) {
		this.mediaConnection.session = {
		    audio: shareAudio,
		    video: shareVideo
		};
		for (var streamid in this.mediaConnection.localStreams) {
			var stream = this.mediaConnection.streams[streamid];
			if (!shareAudio || !shareVideo) {
				stream.mute({
				    audio: !shareAudio,
				    video: !shareVideo
				});
			}
			if (shareAudio || shareVideo) {
				stream.unmute({
				    audio: shareAudio,
				    video: shareVideo
				});
			}
		}
	}

	/**
	 * Decrease the size of the video element for the userid.
	 */
	this.shrinkVideo = function(user) {
		var streams = this.mediaConnection.streams.selectAll({remote:true, local:true});
		for (i = 0; i < streams.length; i++) {
			stream = streams[i];
			if (stream.userid == user) {
			    stream.mediaElement.height = stream.mediaElement.height / 1.5;
			}
		}
	};

	/**
	 * Increase the size of the video element for the userid.
	 */
	this.expandVideo = function(user) {
		var streams = this.mediaConnection.streams.selectAll({remote:true, local:true});
		for (i = 0; i < streams.length; i++) {
			stream = streams[i];
			if (stream.userid == user) {
			    stream.mediaElement.height = stream.mediaElement.height * 1.5;
			}
		}
	};

	/**
	 * Mute the audio for the userid.
	 */
	this.muteAudio = function(user) {
		var streams = this.mediaConnection.streams.selectAll({remote:true, local:true});
		for (i = 0; i < streams.length; i++) {
			stream = streams[i];
			if (stream.userid == user) {
			    stream.mute({
			        audio: true
			    });
			}
		}
	};

	/**
	 * Mute the video for the userid.
	 */
	this.muteVideo = function(user) {
		var streams = this.mediaConnection.streams.selectAll({remote:true, local:true});
		for (i = 0; i < streams.length; i++) {
			stream = streams[i];
			if (stream.userid == user) {
			    stream.mute({
			        video: true
			    });
			}
		}			
	};

	/**
	 * Sent a text message to the channel.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 * Note, the listener will receive its own messages.
	 */
	this.sendMessage = function(message) {
		this.checkSocket();
		this.socket.send(message);
	};

	this.sendAttachment = function(file, resize, form) {
		var self = this;
		var media = new MediaConfig();
		if (this.channel == null) {
			this.listener.error("Missing channel property");
			return false;
		}
		media.instance = this.channel.id;
		media.name = file.name;
		media.type = file.type;
		if (!resize && file.size > SDK.MAX_FILE_UPLOAD) {
			this.listener.error("File exceeds maximum upload size of " + (SDK.MAX_FILE_UPLOAD / 1000000) + "meg");
		} else {
			this.sdk.error = function(message) {
				self.listener.error(message);
			}
			this.sdk.createChannelAttachment(media, file, resize, form, function(media) {
				var message = "file: " + file.name + " : " + file.type + " : " + self.sdk.fetchLink(media.file);
				self.sendMessage(message);
			})
		}
		return false;
	};

	/**
	 * Accept a private request.
	 * This is also used by an operator to accept the top of the waiting queue.
	 * This can also be used by a user to chat with the channel bot.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 */
	this.accept = function() {
		this.checkSocket();
		this.socket.send("accept");
	};

	/**
	 * Test the connection.
	 * A pong message will be returned, this message will not be broadcast to the channel.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 */
	this.ping = function() {
		this.checkSocket();
		this.socket.send("ping");
	};

	/**
	 * Exit from the current private channel.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 */
	this.exit = function() {
		this.checkSocket();
		this.socket.send("exit");
	};

	/**
	 * Change to spy mode.
	 * This allows admins to monitor the entire channel.
	 */
	this.spyMode = function() {
		this.checkSocket();
		this.socket.send("mode: spy");
	};

	/**
	 * Change to normal mode.
	 */
	this.normalMode = function() {
		this.checkSocket();
		this.socket.send("mode: normal");
	};

	/**
	 * Request a private chat session with a user.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 */
	this.pvt = function(user) {
		this.checkSocket();
		this.socket.send("pvt: " + user);
	};

	/**
	 * Boot a user from the channel.
	 * You must be a channel administrator to boot a user.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 */
	this.boot = function(user) {
		this.checkSocket();
		this.socket.send("boot: " + user);
	};

	/**
	 * Send a private message to a user.
	 * This call is asynchronous, any error or success with be sent as a separate message to the listener.
	 */
	this.whisper = function(user, message) {
		this.checkSocket();
		this.socket.send("whisper:" + user + ": " + message);
	};

	/**
	 * Disconnect from the channel.
	 */
	this.disconnect = function() {
    	this.setKeepAlive(false);
    	if (this.socket != null) {
    		this.socket.disconnect();
    	}
    	disconnectMedia();
	};
	
	this.checkSocket = function() {
		if (this.socket == null) {
			throw "Not connected";
		}
	};

	this.toggleKeepAlive = function() {
		this.setKeepAlive(!this.keepAlive);
	}

	this.setKeepAlive = function(keepAlive) {
		this.keepAlive = keepAlive;
		if (!keepAlive && this.keepAliveInterval != null) {
			clearInterval(this.keepAliveInterval);
		} else if (keepAlive && this.keepAliveInterval == null) {
			this.keepAliveInterval = setInterval(
					function() {
						this.ping()
					},
					600000);
		}
	}
}

/**
* Connection class for a REST service connection.
* The SDK connection gives you access to the Paphus Live Chat or libre server services using a REST API.
* <p>
* The services include:
* <ul>
* <li> User management (account creation, validation)
* <li> Bot access, chat, and administration
* <li> Forum access, posting, and administration
* <li> Live chat access, chat, and administration
* <li> Domain access, and administration
* </ul>
 * @class
 * @property user
 * @property domain
 * @property credentials
 * @property debug
 * @property error
*/
function SDKConnection() {
	this.user;
	this.domain;
	this.credentials = new Credentials();
	this.debug = SDK.debug;
	this.error = SDK.error;
	
	this.exception;
	
	/**
	 * Validate the user credentials (password, or token).
	 * The user details are returned (with a connection token, password removed).
	 * The user credentials are soted in the connection, and used on subsequent calls.
	 * An SDKException is thrown if the connect failed.
	 */
	this.connect = function(config, processor) {
		var self = this;
		this.fetchUser(config, function(user) {
			self.user = user;
			processor(user);
		});
	}
	
	/**
	 * Connect to the live chat channel and return a LiveChatConnection.
	 * A LiveChatConnection is separate from an SDKConnection and uses web sockets for
	 * asynchronous communication.
	 * The listener will be notified of all messages.
	 */
	this.openLiveChat = function(channel, listener) {
		var connection = new LiveChatConnection();
		connection.sdk = this;
		connection.credentials = this.credentials;
		connection.listener = listener;
		connection.connect(channel, this.user);
		return connection;
	}
	
	/**
	 * Connect to the domain.
	 * A domain is an isolated content space.
	 * Any browse or query request will be specific to the domain's content.
	 */	
	this.switchDomain = function(config, processor) {
		var self = this;
		this.fetch(config, function(domain) {
			self.domain = domain;
			processor(domain);
		});
	}
	
	/**
	 * Disconnect from the connection.
	 * An SDKConnection does not keep a live connection, but this resets its connected user and domain.
	 */	
	this.disconnect = function() {
		this.user = null;
		this.domain = null;
	}
	
	/**
	 * Fetch the user details for the user credentials.
	 * A token or password is required to validate the user.
	 */	
	this.fetchUser = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/check-user", config.toXML(), function(xml) {
			if (xml == null) {
				return;
			}
			var user = new UserConfig();
			user.parseXML(xml);
			processor(user);
		});
	}
	
	/**
	 * Fetch the URL for the image from the server.
	 */	
	this.fetchImage = function(image) {
		return this.credentials.url + "/" + image;
	}
	
	/**
	 * Fetch the URL for the image from the server.
	 */	
	this.fetchLink = function(image) {
		return this.credentials.url + "/" + image;
	}
	
	/**
	 * Fetch the forum post details for the forum post id.
	 */	
	this.fetchForumPost = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/check-forum-post", config.toXML(), function(xml) {
			if (xml == null) {
				return;
			}
			var post = new ForumPostConfig();
			post.parseXML(xml);
			processor(post);
		});
	}
	
	/**
	 * Create a new user.
	 */
	this.createUser = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/create-user", config.toXML(), function(xml) {
			if (xml == null) {
				return null;
			}
			var user = new UserConfig();
			user.parseXML(xml);
			this.user = user;
			processor(user);
		});
	}

	/**
	 * Create a new file/image/media attachment for a chat channel.
	 */
	this.createChannelAttachment = function(config, file, resize, form, processor) {
		config.addCredentials(this);
		if (resize) {
			this.POST_IMAGE(this.credentials.rest + "/create-channel-attachment", file, form, config.toXML(), function(xml) {
				if (xml == null) {
					return null;
				}
				var media = new MediaConfig();
				media.parseXML(xml);
				processor(media);
			});
		} else {
			this.POST_FILE(this.credentials.rest + "/create-channel-attachment", form, config.toXML(), function(xml) {
				if (xml == null) {
					return null;
				}
				var media = new MediaConfig();
				media.parseXML(xml);
				processor(media);
			});
		}
	}

	/**
	 * Create a new file/image/media attachment for a forum.
	 */
	this.createForumAttachment = function(config, file, resize, form, processor) {
		config.addCredentials(this);
		if (resize) {
			this.POST_IMAGE(this.credentials.rest + "/create-forum-attachment", file, form, config.toXML(), function(xml) {
				if (xml == null) {
					return null;
				}
				var media = new MediaConfig();
				media.parseXML(xml);
				processor(media);
			});
		} else {
			this.POST_FILE(this.credentials.rest + "/create-forum-attachment", form, config.toXML(), function(xml) {
				if (xml == null) {
					return null;
				}
				var media = new MediaConfig();
				media.parseXML(xml);
				processor(media);
			});
		}
	}

	/**
	 * Create a new file/image/media attachment for a forum and insert the http link into the textarea.
	 */
	this.uploadForumAttachment = function(forum, resize, processor) {
		if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
			this.error('The File APIs are not fully supported in this browser.');
			return false;
		}
		var form = document.createElement("form");
		form.enctype = "multipart/form-data";
		form.method = "post";
		form.name = "fileinfo";
		var fileInput = document.createElement("input");
		var self = this;
		fileInput.name = "file";
		fileInput.type = "file";
		form.appendChild(fileInput);
		fileInput.onchange = function() {
			var file = fileInput.files[0];
			self.uploadForumFile(file, forum, resize, form, processor);
		}
		fileInput.click();
	};

	/**
	 * Create a new file/image/media attachment for a forum.
	 */
	this.uploadForumFile = function(file, forum, resize, form, processor) {
		var self = this;
		var media = new MediaConfig();
		media.instance = forum;
		media.name = file.name;
		media.type = file.type;
		if (!resize && file.size > SDK.MAX_FILE_UPLOAD) {
			this.error("File exceeds maximum upload size of " + (SDK.MAX_FILE_UPLOAD / 1000000) + "meg");
		} else {
			this.createForumAttachment(media, file, resize, form, function(media) {
				var link = self.fetchLink(media.file);
				if (processor != null) {
					processor(link, file.name);
				}
			})
		}
	};
	
	/**
	 * Create a new forum post.
	 * You must set the forum id for the post.
	 */
	this.createForumPost = function(config, processor) {
		config.addCredentials(this);
		var xml = POST(this.credentials.rest + "/create-forum-post", config.toXML(), function(xml) {
			if (xml == null) {
				return null;
			}
			var post = new ForumPostConfig();
			post.parseXML(xml);
			processor(post);
		});
	}
	
	/**
	 * Create a reply to a forum post.
	 * You must set the parent id for the post replying to.
	 */
	this.createReply = function(config, processor) {
		config.addCredentials(this);
		var xml = POST(this.credentials.rest + "/create-reply", config.toXML(), function(xml) {
			if (xml == null) {
				return null;
			}
			var reply = new ForumPostConfig();
			reply.parseXML(xml);
			processor(reply);			
		});
	}
	
	/**
	 * Fetch the content details from the server.
	 * The id or name and domain of the object must be set.
	 */
	this.fetch = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/check-" + config.type, config.toXML(), function(xml) {
			if (xml == null) {
				return null;
			}
			var config2 = new config.constructor();
			config2.parseXML(xml);
			processor(config2)
		});
	}
	
	/**
	 * Update the forum post.
	 */
	this.updateForumPost = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/update-forum-post", config.toXML(), function(xml) {
			if (xml == null) {
				return null;
			}
			var config = new ForumPostConfig();
			config.parseXML(xml);
			processor(config);			
		});
	}
	
	/**
	 * Update the user details.
	 * The password must be passed to allow the update.
	 */
	this.updateUser = function(config) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/update-user", config.toXML(), function(xml) {
			return;
		});
	}
	
	/**
	 * Permanently delete the forum post with the id.
	 */
	this.deleteForumPost = function(config) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/delete-forum-post", config.toXML(), function(xml) {
			return;
		});
	}
	
	/**
	 * Flag the content as offensive, a reason is required.
	 */
	this.flag = function(config) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/flag-" + config.getType(), config.toXML(), function(xml) {
			return;
		});
	}
	
	/**
	 * Flag the forum post as offensive, a reason is required.
	 */
	this.flagForumPost = function(config) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/flag-forum-post", config.toXML(), function(xml) {
			return;
		});
	}
	
	/**
	 * Flag the user post as offensive, a reason is required.
	 */
	this.flagUser = function(config) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/flag-user", config.toXML(), function(xml) {
			return;
		});
	}
	
	/**
	 * Process the bot chat message and return the bot's response.
	 * The ChatConfig should contain the conversation id if part of a conversation.
	 * If a new conversation the conversation id is returned in the response. 
	 */
	this.chat = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/post-chat", config.toXML(), function(xml) {
			if (xml == null) {
				return null;
			}
			var responseMessage = new ChatResponse();
			responseMessage.parseXML(xml);
			processor(responseMessage);			
		});
	}
	
	/**
	 * Process the avatar message and return the avatar's response.
	 */
	this.avatarMessage = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/avatar-message", config.toXML(), function(xml) {
			if (xml == null) {
				return null;
			}
			var responseMessage = new ChatResponse();
			responseMessage.parseXML(xml);
			processor(responseMessage);			
		});
	}
	
	/**
	 * Return the list of user details for the comma separated values list of user ids.
	 */
	this.fetchAllUsers = function(usersCSV, processor) {
		var config = new UserConfig();
		config.user = usersCSV;
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/get-users", config.toXML(), function(xml) {
			var users = [];
			if (xml != null) {
				for (var index = 0; index < xml.childNodes.length; index++) {
					var child = xml.childNodes[index];
					var userConfig = new UserConfig();
					userConfig.parseXML(child);
					users[user.length] = userConfig;
				}
			}
			processor(users);
		});
	}
	
	/**
	 * Return the list of forum posts for the forum browse criteria.
	 */
	this.fetchPosts = function(config, processor) {
		config.addCredentials(this);
		var xml = this.POST(this.credentials.rest + "/get-forum-posts", config.toXML(), function(xml) {
			var instances = [];
			if (xml != null) {
				for (var index = 0; index < xml.childNodes.length; index++) {
					var child = xml.childNodes[index];
					var post = new ForumPostConfig();
					post.parseXML(child);
					instances[instances.length] = post;
				}
			}
			processor(instances);
		});
	}
	
	/**
	 * Return the list of categories for the type, and domain.
	 */
	this.fetchCategories = function(config, processor) {
		config.addCredentials(this);
		var xml = this.POST(this.credentials.rest + "/get-categories", config.toXML(), function(xml) {
			var categories = [];
			categories[0] = "";
			if (xml != null) {
				for (var index = 0; index < xml.childNodes.length; index++) {
					categories[categories.length] = (xml.childNodes[index].getAttribute("name"));
				}
			}
			processor(categories);
		});
	}
	
	/**
	 * Return the list of tags for the type, and domain.
	 */
	this.fetchTags = function(config, processor) {
		config.addCredentials(this);
		var xml = this.POST(this.credentials.rest + "/get-tags", config.toXML(), function(xml) {
			var tags = [];
			tags[0] = "";
			if (xml != null) {
				for (var index = 0; index < xml.childNodes.length; index++) {
					tags[tags.length] = (xml.childNodes[index].getAttribute("name"));
				}
			}
			processor(tags);			
		});
	}
	
	/**
	 * Return the users for the content.
	 */
	this.fetchUsers = function(config, processor) {
		config.addCredentials(this);
		var xml = this.POST(this.credentials.rest + "/get-" + config.getType() + "-users", config.toXML(), function(xml) {
			var users = [];
			if (xml != null) {
				for (var index = 0; index < xml.childNodes.length; index++) {
					var user = new UserConfig();
					user.parseXML(xml.childNodes[index]);
					users[users.length] = (user.user);
				}
			}
			processor(users);
			
		});
	}
	
	/**
	 * Initialize the bot's avatar for a chat session.
	 * This can be done before processing the first message for a quick response.
	 * @deprecated replaced by initChat()
	 */
	this.initAvatar = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/init-avatar", config.toXML(), function(xml) {
			if (xml == null) {
				return;
			}
			var response = new ChatResponse();
			response.parseXML(xml);
			processor(response);
		});
	}
	
	/**
	 * Initialize the bot's avatar for a chat session.
	 * This can be done before processing the first message for a quick response.
	 */
	this.initChat = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/init-chat", config.toXML(), function(xml) {
			if (xml == null) {
				return;
			}
			var response = new ChatResponse();
			response.parseXML(xml);
			processor(response);
		});
	}
	
	/**
	 * Return the conversation's chat settings.
	 */
	this.chatSettings = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/chat-settings", config.toXML(), function(xml) {
			if (xml == null) {
				return;
			}
			var settings = new ChatSettings();
			settings.parseXML(xml);
			processor(settings);
		});
	}
	
	/**
	 * Return the bot's voice configuration.
	 */
	this.trainInstance = function(config) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/train-instance", config.toXML(), function(xml) {
			return;
		});
	}
	
	/**
	 * Return the bot's voice configuration.
	 */
	this.fetchVoice = function(config, processor) {
		config.addCredentials(this);
		this.POST(this.credentials.rest + "/get-voice", config.toXML(), function(xml) {
			if (xml == null) {
				return;
			}
			var voice = new VoiceConfig();
			voice.parseXML(xml);
			processor(voice);
		});
	}
	
	/**
	 * Return the list of content for the browse criteria.
	 * The type defines the content type (one of Bot, Forum, Channel, Domain).
	 */
	this.browse = function(config, processor) {
		config.addCredentials(this);
		var type = "";
		if (config.type == "Bot") {
			type = "/get-instances";
		} else if (config.type == "Forum") {
			type = "/get-forums";
		} else if (config.type == "Channel") {
			type = "/get-channels";
		} else if (config.type == "Domain") {
			type = "/get-domains";
		} else if (config.type == "Graphic") {
			type = "/get-graphics";
		} else if (config.type == "Avatar") {
			type = "/get-avatars";
		} else if (config.type == "Script") {
			type = "/get-scripts";
		}
		this.POST(this.credentials.rest + type, config.toXML(), function(xml) {
			var instances = [];
			if (xml != null) {
				for (var index = 0; index < xml.childNodes.length; index++) {
					var instance = null;
					if (config.type == "Bot") {
						instance = new InstanceConfig();
					} else if (config.type == "Forum") {
						instance = new ForumConfig();
					} else if (config.type == "Channel") {
						instance = new ChannelConfig();
					} else if (config.type == "Domain") {
						instance = new DomainConfig();
					} else if (config.type == "Avatar") {
						instance = new AvatarConfig();
					} else if (config.type == "Script") {
						instance = new ScriptConfig();
					} else if (config.type == "Graphic") {
						instance = new GraphicConfig();
					}
					instance.parseXML(xml.childNodes[index]);
					instances[instances.length] = (instance);
				}
			}
			processor(instances);
		});
	}

	this.GET = function(url, processor) {	
		if (this.debug) {
			console.log("GET: " + url);
		}
		var xml = null;
		var request = new XMLHttpRequest();
		var debug = this.debug;
		var self = this;
		request.onreadystatechange = function() {
			if (request.readyState != 4) return;
			if (request.status != 200) {
				console.log('Error: SDK GET web request failed');
				if (debug) {
					console.log(request.statusText);
					console.log(request.responseText);
					console.log(request.responseXML);
				}
				if (request.statusText != null && request.responseText != null && request.responseText.indexOf("<html>") != -1) {
					self.error(request.statusText);					
				} else {
					self.error(request.responseText);
				}
				return;
			}
			processor(request.responseXML.childNodes[0]);
		}
		
		request.open('GET', url, true);
		request.send();
	}

	this.POST = function(url, xml, processor) {
		if (this.debug) {
			console.log("POST: " + url);
			console.log("XML: " + xml);
		}
		var request = new XMLHttpRequest();
		var debug = this.debug;
		var self = this;
		request.onreadystatechange = function() {
			if (debug) {
				console.log(request.readyState);
				console.log(request.status);
				console.log(request.statusText);
				console.log(request.responseText);
				console.log(request.responseXML);
			}
			if (request.readyState != 4) return;
			if (request.status != 200 && request.status != 204) {
				console.log('Error: SDK POST web request failed');
				if (debug) {
					console.log(request.statusText);
					console.log(request.responseText);
					console.log(request.responseXML);
				}
				if (request.statusText != null && request.responseText != null && request.responseText.indexOf("<html>") != -1) {
					self.error(request.statusText);					
				} else {
					self.error(request.responseText);
				}
				return;
			}
			processor(request.responseXML.childNodes[0]);
		};
		
		request.open('POST', url, true);
		request.setRequestHeader("Content-Type", "application/xml");
		request.send(xml);
	}
	
	this.POST_FILE = function(url, form, xml, processor) {
		if (this.debug) {
			console.log("POST FILE: " + url);
			console.log("FORM: " + form);
			console.log("XML: " + xml);
		}
		var request = new XMLHttpRequest();
		var formData = new FormData(form);
		formData.append("xml", xml);
		var debug = this.debug;
		var self = this;
		request.onreadystatechange = function() {
			if (debug) {
				console.log(request.readyState);
				console.log(request.status);
				console.log(request.statusText);
				console.log(request.responseText);
				console.log(request.responseXML);
			}
			if (request.readyState != 4) return;
			if (request.status != 200 && request.status != 204) {
				console.log('Error: SDK POST web request failed');
				if (debug) {
					console.log(request.statusText);
					console.log(request.responseText);
					console.log(request.responseXML);
				}
				if (request.statusText != null && request.responseText != null && request.responseText.indexOf("<html>") != -1) {
					self.error(request.statusText);					
				} else {
					self.error(request.responseText);
				}
				return;
			}
			processor(request.responseXML.childNodes[0]);
		};
		
		request.open('POST', url, true);
		//request.setRequestHeader("Content-Type", "multipart/form-data");
		request.send(formData);
	}
	
	this.POST_IMAGE = function(url, file, form, xml, processor) {
		var self = this;
		var debug = this.debug;
		var reader = new FileReader();
		reader.onloadend = function() {
			var tempImg = new Image();
			tempImg.src = reader.result;
			tempImg.onload = function() {
				var MAX_WIDTH = 300;
				var MAX_HEIGHT = 300;
				var tempW = tempImg.width;
				var tempH = tempImg.height;
				if (tempW > tempH) {
					if (tempW > MAX_WIDTH) {
						 tempH *= MAX_WIDTH / tempW;
						 tempW = MAX_WIDTH;
					}
				} else {
					if (tempH > MAX_HEIGHT) {
						 tempW *= MAX_HEIGHT / tempH;
						 tempH = MAX_HEIGHT;
					}
				}
				var canvas = document.createElement('canvas');
				canvas.width = tempW;
				canvas.height = tempH;
				var ctx = canvas.getContext("2d");
				ctx.fillStyle = '#fff';
				ctx.fillRect(0, 0, canvas.width, canvas.height);				
				ctx.drawImage(this, 0, 0, tempW, tempH);
	            var dataUrl = canvas.toDataURL('image/jpeg');
	            var blob = SDK.dataURLToBlob(dataUrl);

				var request = new XMLHttpRequest();
				var formData = new FormData();
				formData.append("xml", xml);
				formData.append('file', blob, file.name);
				request.onreadystatechange = function() {
					if (debug) {
						console.log(request.readyState);
						console.log(request.status);
						console.log(request.statusText);
						console.log(request.responseText);
						console.log(request.responseXML);
					}
					if (request.readyState != 4) return;
					if (request.status != 200 && request.status != 204) {
						console.log('Error: SDK POST web request failed');
						if (debug) {
							console.log(request.statusText);
							console.log(request.responseText);
							console.log(request.responseXML);
						}
						if (request.statusText != null && request.responseText != null && request.responseText.indexOf("<html>") != -1) {
							self.error(request.statusText);					
						} else {
							self.error(request.responseText);
						}
						return;
					}
					processor(request.responseXML.childNodes[0]);
				};
				
				request.open('POST', url, true);
				//request.setRequestHeader("Content-Type", "multipart/form-data");
				request.send(formData);
			}
		 }
		 reader.readAsDataURL(file);
	}
}

/**
 * Abstract root class for all web API message objects.
 * Defines the required application id, and common fields.
 * @class
 * @property application
 * @property domain
 * @property user
 * @property token
 * @property instance
 * @property type
 */
function Config() {
	/** The application ID.  This is require to authenticate the API usage.  You can obtain your application ID from your user page. */
	this.application;
	/** Optional domain id, if object is not on the server's default domain. */
	this.domain;
	/** User ID, required for content creation, secure content access, or to identify the user. */
	this.user;
	/** User's access token, returned from connect web API, can be used in place of password in subsequent calls, and stored in a cookie.   The user's password should never be stored. */
	this.token;
	/** The id or name of the bot or content instance to access. */
	this.instance;
	/** Type of instance to access, ("Bot", "Forum", "Channel", "Domain") */
	this.type;
	
	this.addCredentials = function(connection) {
		this.application = connection.credentials.applicationId;
		if (connection.user != null) {
			this.user = connection.user.user;
			this.token = connection.user.token;
		}
		if (connection.domain != null) {
			this.domain = connection.domain.id;
		}
	}
	
	this.writeCredentials = function(xml) {
		if (this.user != null && this.user.length > 0) {
			xml = xml + (" user=\"" + this.user + "\"");
		}
		if (this.token != null && this.token.length > 0) {
			xml = xml + (" token=\"" + this.token + "\"");
		}
		if (this.type != null && this.type.length > 0) {
			xml = xml + (" type=\"" + this.type + "\"");
		}
		if (this.instance != null && this.instance.length > 0) {
			xml = xml + (" instance=\"" + this.instance + "\"");
		}
		if (this.application != null && this.application.length > 0) {
			xml = xml + (" application=\"" + this.application + "\"");
		}
		if (this.domain != null && this.domain.length > 0) {
			xml = xml + (" domain=\"" + this.domain + "\"");
		}
		return xml;
	}
}

/**
 * This object models a user.
 * It can be used from a chat UI, or with the Libre Web API.
 * It can convert itself to/from XML for web API usage.
 * This can be used to connect, create, edit, or browse a user instance.
 * @class
 * @property password
 * @property newPassword
 * @property hint
 * @property name
 * @property showName
 * @property email
 * @property website
 * @property bio
 * @property over18
 * @property avatar
 * @property connects
 * @property bots
 * @property posts
 * @property messages
 * @property joined
 * @property lastConnect
 */
function UserConfig() {
	/** Password, require to connect a user, or create a user. */
	this.password;
	/** New password for editting a user's password (password is old password). */
	this.newPassword;
	/** Optional password hint, in case password is forgotten. */
	this.hint;
	/** Optional real name of the user. */
	this.name;
	/** The real name can be hidden from other users. */
	this.showName;
	/** Email, required for message notification, and to reset password. */
	this.email;
	/** Optional user's website. */
	this.website;
	/** Optional user's bio. */
	this.bio;
	this.over18;
	/** Read-only, server local URL for user's avatar image. */
	this.avatar;

	/** Read-only, total user connects. */
	this.connects;
	/** Read-only, total bots created. */
	this.bots;
	/** Read-only, total forum posts. */
	this.posts;
	/** Read-only, total chat messages. */
	this.messages;
	/** Read-only, date user joined. */
	this.joined;
	/** Read-only, date of user's last connect. */
	this.lastConnect;
	
	this.addCredentials = function(connection) {
		this.application = connection.credentials.applicationId;
		if (connection.domain != null) {
			this.domain = connection.domain.id;
		}
	}

	this.parseXML = function(element) {
		this.user = element.getAttribute("user");
		this.name = element.getAttribute("name");
		this.showName = element.getAttribute("showName");
		this.token = element.getAttribute("token");
		this.email = element.getAttribute("email");
		this.hint = element.getAttribute("hint");
		this.website = element.getAttribute("website");
		this.connects = element.getAttribute("connects");
		this.bots = element.getAttribute("bots");
		this.posts = element.getAttribute("posts");
		this.messages = element.getAttribute("messages");
		this.joined = element.getAttribute("joined");
		this.lastConnect = element.getAttribute("lastConnect");
		
		var node = element.getElementsByTagName("bio")[0];
		if (node != null) {
			this.bio = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("avatar")[0];
		if (node != null) {
			this.avatar = SDK.innerHTML(node);
		}
	}
	
	this.toXML = function() {
		var xml = "<user";
		xml = this.writeCredentials(xml);
		if (this.password != null) {
			xml = xml + (" password=\"" + this.password + "\"");
		}
		if (this.newPassword != null) {
			xml = xml + (" newPassword=\"" + this.newPassword + "\"");
		}
		if (this.hint != null) {
			xml = xml + (" hint=\"" + this.hint + "\"");
		}
		if (this.name != null) {
			xml = xml + (" name=\"" + this.name + "\"");
		}
		if (this.showName) {
			xml = xml + (" showName=\"" + this.showName + "\"");
		}
		if (this.email != null) {
			xml = xml + (" email=\"" + this.email + "\"");
		}
		if (this.website != null) {
			xml = xml + (" website=\"" + this.website + "\"");
		}
		if (this.over18) {
			xml = xml + (" over18=\"" + this.over18 + "\"");
		}
		xml = xml + (">");
		
		if (this.bio != null) {
			xml = xml + ("<bio>");
			xml = xml + (SDK.escapeHTML(this.bio));
			xml = xml + ("</bio>");
		}
		xml = xml + ("</user>");
		return xml;
	}
		
}
UserConfig.prototype = new Config();
UserConfig.prototype.constructor = UserConfig;
UserConfig.constructor = UserConfig;

/**
 * This object models a chat message sent to a chat bot instance.
 * It can be used from a chat UI, or with the Libre Web API.
 * It can convert itself to XML for web API usage.
 * @class
 * @property conversation
 * @property speak
 * @property correction
 * @property offensive
 * @property disconnect
 * @property emote
 * @property action
 * @property message
 * @property debug
 * @property debugLevel
 * @property learn
 */
function ChatConfig() {
	/** The conversation id for the message.  This will be returned from the first response, and must be used for all subsequent messages to maintain the conversational state.  Without the conversation id, the bot has no context for the reply. */
	this.conversation;
	/** Sets if the voice audio should be generated for the bot's response. */
	this.speak;
	/** Sets the message to be a correction to the bot's last response. */
	this.correction;
	/** Flags the bot's last response as offensive. */
	this.offensive;
	/** Ends the conversation. Conversation should be terminated to converse server resources.  The message can be blank. */
	this.disconnect;
	/** 
	 * Attaches an emotion to the user's message, one of:
	 *  NONE,
	 *  LOVE, LIKE, DISLIKE, HATE,
	 *	RAGE, ANGER, CALM, SERENE,
	 *	ECSTATIC, HAPPY, SAD, CRYING,
	 *	PANIC, AFRAID, CONFIDENT, COURAGEOUS,
	 *	SURPRISE, BORED,
	 *	LAUGHTER, SERIOUS
	 */
	this.emote;
	/** Attaches an action to the user's messages, such as "laugh", "smile", "kiss". */
	this.action;
	/** The user's message text. */
	this.message;
	/** Include the message debug log in the response. */
	this.debug;
	/** Set the debug level, one of: SEVER, WARNING, INFO, CONFIG, FINE, FINER. */
	this.debugLevel;
	/** Enable or disable the bot's learning for this message. */
	this.learn;
	/** Escape and filter the response message HTML content for XSS security. */
	this.secure = true;
	/** Strip any HTML tags from the response message. */
	this.plainText;
	/** Send extra info with the message, such as the user's contact info (name email phone). */
	this.info;
	/** Request a specific avatar (by ID). */
	this.avatar;
	/** Request the response avatar media in HD. */
	this.avatarHD = SDK.hd;
	/** Request the response avatar media in a video or image format. */
	this.avatarFormat = SDK.format;
	/** Translate between the user's language and the bot's language. */
	this.language;
	
	this.toXML = function() {
		var xml = "<chat";
		xml = this.writeCredentials(xml);
		if (this.conversation != null) {
			xml = xml + (" conversation=\"" + this.conversation + "\"");
		}
		if (this.emote != null) {
			xml = xml + (" emote=\"" + this.emote + "\"");
		}
		if (this.action != null) {
			xml = xml + (" action=\"" + this.action + "\"");
		}
		if (this.speak) {
			xml = xml + (" speak=\"" + this.speak + "\"");
		}
		if (this.language != null) {
			xml = xml + (" language=\"" + this.language + "\"");
		}
		if (this.avatarHD) {
			xml = xml + (" avatarHD=\"" + this.avatarHD + "\"");
		}
		if (this.avatarFormat != null) {
			xml = xml + (" avatarFormat=\"" + this.avatarFormat + "\"");
		}
		if (this.correction) {
			xml = xml + (" correction=\"" + this.correction + "\"");
		}
		if (this.offensive) {
			xml = xml + (" offensive=\"" + this.offensive + "\"");
		}
		if (this.learn != null) {
			xml = xml + (" learn=\"" + this.learn + "\"");
		}
		if (this.secure != null) {
			xml = xml + (" secure=\"" + this.secure + "\"");
		}
		if (this.plainText != null) {
			xml = xml + (" plainText=\"" + this.plainText + "\"");
		}
		if (this.debug) {
			xml = xml + (" debug=\"" + this.debug + "\"");
		}
		if (this.info) {
			xml = xml + (" info=\"" + SDK.escapeHTML(this.info) + "\"");
		}
		if (this.debugLevel != null) {
			xml = xml + (" debugLevel=\"" + this.debugLevel + "\"");
		}
		if (this.disconnect) {
			xml = xml + (" disconnect=\"" + this.disconnect + "\"");
		}
		xml = xml + (">");
		
		if (this.message != null) {
			xml = xml + ("<message>");
			xml = xml + (SDK.escapeHTML(this.message));
			xml = xml + ("</message>");
		}
		xml = xml + ("</chat>");
		return xml;
	}
}
ChatConfig.prototype = new Config();
ChatConfig.prototype.constructor = ChatConfig;
ChatConfig.constructor = ChatConfig;

/**
 * This object models a chat message received from a chat bot instance.
 * It can be used from a chat UI, or with the Libre Web API.
 * It can convert itself from XML for web API usage.
 * @class
 * @property conversation
 * @property avatar
 * @property avatarType
 * @property avatarTalk
 * @property avatarTalkType
 * @property avatarAction
 * @property avatarActionType
 * @property avatarActionAudio
 * @property avatarActionAudioType
 * @property avatarAudio
 * @property avatarAudioType
 * @property avatarBackground
 * @property speech
 * @property message
 * @property question
 * @property emote
 * @property action
 * @property pose
 * @property log
 */
function ChatResponse() {	
	/** The conversation id for the message.  This will be returned from the first response, and must be used for all subsequent messages to maintain the conversational state.  Without the conversation id, the bot has no context for the reply. */
	this.conversation;
	/** Server relative URL for the avatar image or video. */
	this.avatar;
	/** Second avatar animation. */
	this.avatar2;
	/** Third avatar animation. */
	this.avatar3;
	/** Forth avatar animation. */
	this.avatar4;
	/** Fifth avatar animation. */
	this.avatar5;
	/** Avatar MIME file type, (mpeg, webm, ogg, jpeg, png) */
	this.avatarType;
	/** Server relative URL for the avatar talking image or video. */
	this.avatarTalk;
	/** Avatar talk MIME file type, (mpeg, webm, ogg, jpeg, png) */
	this.avatarTalkType;
	/** Server relative URL for the avatar action image or video. */
	this.avatarAction;
	/** Avatar action MIME file type, (mpeg, webm, ogg, jpeg, png) */
	this.avatarActionType;
	/** Server relative URL for the avatar action audio image or video. */
	this.avatarActionAudio;
	/** Avatar action audio MIME file type,  (mpeg, wav) */
	this.avatarActionAudioType;
	/** Server relative URL for the avatar audio image or video. */
	this.avatarAudio;
	/** Avatar audio MIME file type,  (mpeg, wav) */
	this.avatarAudioType;
	/** Server relative URL for the avatar background image. */
	this.avatarBackground;
	/** Server relative URL for the avatar speech audio file. */
	this.speech;
	/** The bot's message text. */
	this.message;
	/** Optional text to the original question. */
	this.question;
	/**
	 * Emotion attached to the bot's message, one of:
	 *  NONE,
	 *  LOVE, LIKE, DISLIKE, HATE,
	 *	RAGE, ANGER, CALM, SERENE,
	 *	ECSTATIC, HAPPY, SAD, CRYING,
	 *	PANIC, AFRAID, CONFIDENT, COURAGEOUS,
	 *	SURPRISE, BORED,
	 *	LAUGHTER, SERIOUS
	 */
	this.emote;
	/** Action for the bot's messages, such as "laugh", "smile", "kiss", or mobile directive (for virtual assistants). */
	this.action;
	/** Pose for the bot's messages, such as "dancing", "sitting", "sleeping". */
	this.pose;
	/** The debug log of processing the message. */
	this.log;

	this.parseXML = function(element) {
		this.conversation = element.getAttribute("conversation");
		this.avatar = element.getAttribute("avatar");
		this.avatar2 = element.getAttribute("avatar2");
		this.avatar3 = element.getAttribute("avatar3");
		this.avatar4 = element.getAttribute("avatar4");
		this.avatar5 = element.getAttribute("avatar5");
		this.avatarType = element.getAttribute("avatarType");
		this.avatarTalk = element.getAttribute("avatarTalk");
		this.avatarTalkType = element.getAttribute("avatarTalkType");
		this.avatarAction = element.getAttribute("avatarAction");
		this.avatarActionType = element.getAttribute("avatarActionType");
		this.avatarActionAudio = element.getAttribute("avatarActionAudio");
		this.avatarActionAudioType = element.getAttribute("avatarActionAudioType");
		this.avatarAudio = element.getAttribute("avatarAudio");
		this.avatarAudioType = element.getAttribute("avatarAudioType");
		this.avatarBackground = element.getAttribute("avatarBackground");
		this.emote = element.getAttribute("emote");
		this.action = element.getAttribute("action");
		this.pose = element.getAttribute("pose");
		this.speech = element.getAttribute("speech");

		var node = element.getElementsByTagName("message")[0];
		if (node != null) {
			this.message = SDK.innerHTML(node);
		}
		
		node = element.getElementsByTagName("log")[0];
		if (node != null) {
			this.log = SDK.innerHTML(node);
		}
	}
}
ChatResponse.prototype = new Config();
ChatResponse.prototype.constructor = ChatResponse;
ChatResponse.constructor = ChatResponse;

/**
 * This object is returned from the SDK chatSettings() API to retrieve a conversation's chat settings.
 * It can convert itself from XML for web API usage.
 * @class
 * @property conversation
 * @property allowEmotes
 * @property allowCorrection
 * @property allowLearning
 * @property learning
 */
function ChatSettings() {
	this.conversation;
	this.allowEmotes;
	this.allowCorrection;
	this.allowLearning;
	this.learning;

	this.toXML = function() {
		var xml = "<chat-settings";
		xml = this.writeCredentials(xml);
		if (this.conversation != null) {
			xml = xml + (" conversation=\"" + this.conversation + "\"");
		}
		xml = xml + ("/>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.allowEmotes = "true" == (element.getAttribute("allowEmotes"));
		this.allowCorrection = "true" == (element.getAttribute("allowCorrection"));
		this.allowLearning = "true" == (element.getAttribute("allowLearning"));
		this.learning = "true" == (element.getAttribute("learning"));
	}
}
ChatSettings.prototype = new Config();
ChatSettings.prototype.constructor = ChatSettings;
ChatSettings.constructor = ChatSettings;

/**
 * DTO for XML avatar message config.
 * @class
 * @property avatar
 * @property speak
 * @property voice
 * @property message
 * @property emote
 * @property action
 * @property pose
 */
function AvatarMessage() {
	this.avatar;
	this.speak;
	this.voice;
	this.message;
	this.emote;
	this.action;
	this.pose;
	this.hd = SDK.hd;
	this.format = SDK.format;
	
	this.toXML = function() {
		var xml = "<avatar-message";
		xml = this.writeCredentials(xml);
		if (this.avatar != null) {
			xml = xml + (" avatar=\"" + this.avatar + "\"");
		}
		if (this.emote != null) {
			xml = xml + (" emote=\"" + this.emote + "\"");
		}
		if (this.action != null) {
			xml = xml + (" action=\"" + this.action + "\"");
		}
		if (this.pose != null) {
			xml = xml + (" pose=\"" + this.pose + "\"");
		}
		if (this.voice != null) {
			xml = xml + (" voice=\"" + this.voice + "\"");
		}
		if (this.format != null) {
			xml = xml + (" format=\"" + this.format + "\"");
		}
		if (this.speak) {
			xml = xml + (" speak=\"" + this.speak + "\"");
		}
		if (this.hd) {
			xml = xml + (" hd=\"" + this.hd + "\"");
		}
		xml = xml + (">");
		
		if (this.message != null) {
			xml = xml + ("<message>");
			xml = xml + (SDK.escapeHTML(this.message));
			xml = xml + ("</message>");
		}
		xml = xml + ("</avatar-message>");
		return xml;
	}
}
AvatarMessage.prototype = new Config();
AvatarMessage.prototype.constructor = AvatarMessage;
AvatarMessage.constructor = AvatarMessage;

/**
 * This object models the web API browse operation.
 * It can be used to search a set of instances (bots, forums, or channels).
 * @class
 * @property type
 * @property typeFilter
 * @property category
 * @property tag
 * @property filter
 * @property sort
 */
function BrowseConfig() {
	/** Filters instances by access type, "Public", "Private", "Personal". */
	this.typeFilter;
	/** Filters instances by categories (csv) */
	this.category;
	/** Filters instances by tags (csv) */
	this.tag;
	/** Filters instances by name */
	this.filter;
	/** Sorts instances, "name", "date", "size", "stars", "thumbs up", "thumbs down", "last connect", "connects", "connects today", "connects this week ", "connects this month" */
	this.sort;
	
	this.toXML = function() {
		var xml = "<browse";
		xml = this.writeCredentials(xml);
		if (this.typeFilter != null) {
			xml = xml + (" typeFilter=\"" + this.typeFilter + "\"");
		}
		if (this.sort != null) {
			xml = xml + (" sort=\"" + this.sort + "\"");
		}
		if ((this.category != null) && this.category != "") {
			xml = xml + (" category=\"" + this.category + "\"");
		}
		if ((this.tag != null) && this.tag != "") {
			xml = xml + (" tag=\"" + this.tag + "\"");
		}
		if ((this.filter != null) && this.filter != "") {
			xml = xml + (" filter=\"" + this.filter + "\"");
		}
		xml = xml + ("/>");
		return xml;
	}
}
BrowseConfig.prototype = new Config();
BrowseConfig.prototype.constructor = BrowseConfig;
BrowseConfig.constructor = BrowseConfig;

/**
 * Abstract content class.
 * This object models a content object such as a bot, forum, or channel.
 * It can be used from a chat UI, or with the Libre Web API.
 * It can convert itself to/from XML for web API usage.
 * This can be used to create, edit, or browse a content.
 * @class
 * @property id
 * @property name
 * @property isAdmin
 * @property isAdult
 * @property isPrivate
 * @property isHidden
 * @property accessMode
 * @property isFlagged
 * @property flaggedReason
 * @property isExternal
 * @property description
 * @property details
 * @property disclaimer
 * @property tags
 * @property categories
 * @property creator
 * @property creationDate
 * @property lastConnectedUser
 * @property website
 * @property license
 * @property avatar
 * @property connects
 * @property dailyConnects
 * @property weeklyConnects
 * @property monthlyConnects
 */
function WebMediumConfig() {
	/** Instance ID. */
	this.id;
	/** Instance name. */
	this.name;
	/** Read-only, returns if connected user is the content's admin. */
	this.isAdmin;
	this.isAdult;
	/** Sets if the content is private to the creator, and its members. */
	this.isPrivate;
	/** Sets if the conent will be visible and searchable in the content directory. */
	this.isHidden;
	/** Sets the access mode for the content, ("Everyone", "Users", "Members", "Administrators"). */
	this.accessMode;
	/** Returns if the content has been flagged, or used to flag content as offensive (reason required). */
	this.isFlagged;
	/** Returns why the content has been flagged, or used to flag content as offensive. */
	this.flaggedReason;
	/** Can be used to create a link to external content in the content directory. */
	this.isExternal;
	/** Optional description of the content. */
	this.description;
	/** Optional restrictions or details of the content. */
	this.details;
	/** Optional warning or disclaimer of the content. */
	this.disclaimer;
	/** Tags to classify the content (csv). */
	this.tags;
	/** Categories to categorize the content under (csv). */
	this.categories;
	/** Read-only, returns content's creator's user ID. */
	this.creator;
	/** Read-only, returns content's creation date. */
	this.creationDate;
	/** Read-only, returns last user to access content */
	this.lastConnectedUser;
	/** Optional license to license the content under. */
	this.license;
	/** Optional website related to the content. */
	this.website = "";
	/** Read-only, server local URL to content's avatar image. */
	this.avatar;
	/** Read-only, returns content's toal connects. */
	this.connects;
	/** Read-only, returns content's daily connects. */
	this.dailyConnects;
	/** Read-only, returns content's weekly connects. */
	this.weeklyConnects;
	/** Read-only, returns content's monthly connects. */
	this.monthlyConnects;

	this.writeWebMediumXML = function(xml) {
		xml = this.writeCredentials(xml);
		if (this.id != null) {
			xml = xml + (" id=\"" + this.id + "\"");
		}
		if (this.name != null) {
			xml = xml + (" name=\"" + this.name + "\"");
		}
		if (this.isPrivate) {
			xml = xml + (" isPrivate=\"true\"");
		}
		if (this.isHidden) {
			xml = xml + (" isHidden=\"true\"");
		}
		if (this.accessMode != null && this.accessMode != "") {
			xml = xml + (" accessMode=\"" + this.accessMode + "\"");
		}
		if (this.isAdult) {
			xml = xml + (" isAdult=\"true\"");
		}
		if (this.isFlagged) {
			xml = xml + (" isFlagged=\"true\"");
		}
		xml = xml + (">");
		if (this.description != null) {
			xml = xml + ("<description>");
			xml = xml + (SDK.escapeHTML(this.description));
			xml = xml + ("</description>");
		}
		if (this.details != null) {
			xml = xml + ("<details>");
			xml = xml + (SDK.escapeHTML(this.details));
			xml = xml + ("</details>");
		}
		if (this.disclaimer != null) {
			xml = xml + ("<disclaimer>");
			xml = xml + (SDK.escapeHTML(this.disclaimer));
			xml = xml + ("</disclaimer>");
		}
		if (this.categories != null) {
			xml = xml + ("<categories>");
			xml = xml + (SDK.escapeHTML(this.categories));
			xml = xml + ("</categories>");
		}
		if (this.tags != null) {
			xml = xml + ("<tags>");
			xml = xml + (SDK.escapeHTML(this.tags));
			xml = xml + ("</tags>");
		}
		if (this.license != null) {
			xml = xml + ("<license>");
			xml = xml + (SDK.escapeHTML(this.license));
			xml = xml + ("</license>");
		}
		if (this.flaggedReason != null) {
			xml = xml + ("<flaggedReason>");
			xml = xml + (SDK.escapeHTML(this.flaggedReason));
			xml = xml + ("</flaggedReason>");
		}
		return xml;
	}
	
	this.parseWebMediumXML = function(element) {
		this.id = element.getAttribute("id");
		this.name = element.getAttribute("name");
		this.creationDate = element.getAttribute("creationDate");
		this.isPrivate = element.getAttribute("isPrivate");
		this.isHidden = element.getAttribute("isHidden");
		this.accessMode = element.getAttribute("accessMode");
		this.isAdmin = element.getAttribute("isAdmin");
		this.isAdult = element.getAttribute("isAdult");
		this.isFlagged = element.getAttribute("isFlagged");
		this.creator = element.getAttribute("creator");
		this.creationDate = element.getAttribute("creationDate");
		this.connects = element.getAttribute("connects");
		this.dailyConnects = element.getAttribute("dailyConnects");
		this.weeklyConnects = element.getAttribute("weeklyConnects");
		this.monthlyConnects = element.getAttribute("monthlyConnects");
		
		var node = element.getElementsByTagName("description")[0];
		if (node != null) {
			this.description = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("details")[0];
		if (node != null) {
			this.details = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("disclaimer")[0];
		if (node != null) {
			this.disclaimer = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("categories")[0];
		if (node != null) {
			this.categories = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("tags")[0];
		if (node != null) {
			this.tags = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("flaggedReason")[0];
		if (node != null) {
			this.flaggedReason = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("lastConnectedUser")[0];
		if (node != null) {
			this.lastConnectedUser = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("license")[0];
		if (node != null) {
			this.license = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("avatar")[0];
		if (node != null) {
			this.avatar = SDK.innerHTML(node);
		}
	}
}
WebMediumConfig.prototype = new Config();
WebMediumConfig.prototype.constructor = WebMediumConfig;
WebMediumConfig.constructor = WebMediumConfig;

/**
 * This object models a live chat channel or chatroom instance.
 * It can be used from a chat UI, or with the Libre Web API.
 * It can convert itself to/from XML for web API usage.
 * This can be used to create, edit, or browse a channel instance.
 * @class
 * @property type
 * @property messages
 * @property usersOnline
 * @property adminsOnline
 */
function ChannelConfig() {
	/** Sets type, "ChatRoom", "OneOnOne". */
	this.type;
	/** Read-only: total number of messages. */
	this.messages;
	/** Read-only: current users online. */
	this.usersOnline;
	/** Read-only: current admins or operators online. */
	this.adminsOnline;
	
	this.type = "channel";
	
	this.credentials = function() {
		var config = new ChannelConfig();
		config.id = this.id;
		return config;
	}
	
	this.toXML = function() {
		var xml = "<channel";
		if (this.type != null && this.type != "") {
			xml = xml + (" type=\"" + this.type + "\"");
		}
		xml = this.writeWebMediumXML(xml);
		xml = xml + ("</channel>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.parseWebMediumXML(element);
		this.type = element.getAttribute("type");
		this.messages = element.getAttribute("messages");
		this.usersOnline = element.getAttribute("usersOnline");
		this.adminsOnline = element.getAttribute("adminsOnline");
	}
}
ChannelConfig.prototype = new WebMediumConfig();
ChannelConfig.prototype.constructor = ChannelConfig;
ChannelConfig.constructor = ChannelConfig;

/**
 * DTO to parse response of a list of names.
 * This is used for categories, tags, and templates.
 * @class
 * @property type
 */
function ContentConfig() {	
	this.type;	
	
	this.parseXML = function(element) {		
		this.type = element.getAttribute("type");
	}

	
	this.toXML = function() {
		var xml = "<content";
		xml = this.writeCredentials(xml);
		
		xml = xml + ("/>");
		return xml;
	}
}
ContentConfig.prototype = new Config();
ContentConfig.prototype.constructor = ContentConfig;
ContentConfig.constructor = ContentConfig;

/**
 * This object models a domain.
 * It can be used from a chat UI, or with the Libre Web API.
 * A domain is an isolated content space to create bots and other content in (such as a commpany, project, or school).
 * It can convert itself to/from XML for web API usage.
 * This can be used to create, edit, or browse a domain instance.
 * @class
 * @property creationMode
 */
function DomainConfig() {
	this.creationMode;
	
	this.type = "domain";
	
	this.credentials = function() {
		var config = new DomainConfig();
		config.id = this.id;
		return config;
	}
	
	this.toXML = function() {
		var xml = "<domain";
		if (this.creationMode != null && this.creationMode != "") {
			xml = xml + (" creationMode=\"" + this.creationMode + "\"");
		}
		xml = this.writeWebMediumXML(xml);
		xml = xml + ("</domain>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.parseWebMediumXML(element);
		this.creationMode = element.getAttribute("creationMode");
	}
}
DomainConfig.prototype = new WebMediumConfig();
DomainConfig.prototype.constructor = DomainConfig;
DomainConfig.constructor = DomainConfig;

/**
 * This object models an avatar.
 * An avatar represents a bot's visual image, but can also be used independently with TTS.
 * It can convert itself to/from XML for web API usage.
 * This can be used to create, edit, or browse an avatar instance.
 * @class
 */
function AvatarConfig() {
	
	this.type = "avatar";
	
	this.credentials = function() {
		var config = new AvatarConfig();
		config.id = this.id;
		return config;
	}
	
	this.toXML = function() {
		var xml = "<avatar";
		xml = this.writeWebMediumXML(xml);
		xml = xml + ("</avatar>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.parseWebMediumXML(element);
	}
}
AvatarConfig.prototype = new WebMediumConfig();
AvatarConfig.prototype.constructor = AvatarConfig;
AvatarConfig.constructor = AvatarConfig;

/**
 * This object models a script from the script library.
 * It can convert itself to/from XML for web API usage.
 * This can be used to create, edit, or browse an avatar instance.
 * @class
 */
function ScriptConfig() {
	
	this.type = "script";
	
	this.credentials = function() {
		var config = new AvatarConfig();
		config.id = this.id;
		return config;
	}
	
	this.toXML = function() {
		var xml = "<script";
		xml = this.writeWebMediumXML(xml);
		xml = xml + ("</script>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.parseWebMediumXML(element);
	}
}
ScriptConfig.prototype = new WebMediumConfig();
ScriptConfig.prototype.constructor = ScriptConfig;
ScriptConfig.constructor = ScriptConfig;

/**
 * This object models a graphic from the graphics library.
 * It can convert itself to/from XML for web API usage.
 * This can be used to create, edit, or browse an avatar instance.
 * @class
 */
function GraphicConfig() {
	this.media;
	
	this.type = "graphic";
	
	this.credentials = function() {
		var config = new AvatarConfig();
		config.id = this.id;
		return config;
	}
	
	this.toXML = function() {
		var xml = "<graphic";
		xml = this.writeWebMediumXML(xml);
		xml = xml + ("</graphic>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.parseWebMediumXML(element);
		node = element.getElementsByTagName("media")[0];
		if (node != null) {
			this.media = SDK.innerHTML(node);
		}
	}
}
GraphicConfig.prototype = new WebMediumConfig();
GraphicConfig.prototype.constructor = GraphicConfig;
GraphicConfig.constructor = GraphicConfig;

/**
 * This object models a forum instance.
 * It can be used from a chat UI, or with the Libre Web API.
 * It can convert itself to/from XML for web API usage.
 * This can be used to create, edit, or browse a forum instance.
 * @class
 * @property replyAccessMode
 * @property postAccessMode
 * @property posts
 */
function ForumConfig() {
	/** Sets the access mode for forum post replies, ("Everyone", "Users", "Members", "Administrators"). */
	this.replyAccessMode;
	/** Sets the access mode for forum posts, ("Everyone", "Users", "Members", "Administrators"). */
	this.postAccessMode;
	/** Read-only property for the total number of posts to the forum. */
	this.posts;
	
	this.type = "forum";
	
	this.credentials = function() {
		var config = new ForumConfig();
		config.id = this.id;
		return config;
	}
	
	this.toXML = function() {
		var xml = xml + ("<forum");
		if (this.replyAccessMode != null && !this.replyAccessMode == "") {
			xml = xml + (" replyAccessMode=\"" + this.replyAccessMode + "\"");
		}
		if (this.postAccessMode != null && !this.postAccessMode == "") {
			xml = xml + (" postAccessMode=\"" + this.postAccessMode + "\"");
		}
		xml = this.writeWebMediumXML(xml);
		xml = xml + ("</forum>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.parseWebMediumXML(element);
		this.replyAccessMode = element.getAttribute("replyAccessMode");
		this.postAccessMode = element.getAttribute("postAccessMode");
		this.posts = element.getAttribute("posts");
	}
}
ForumConfig.prototype = new WebMediumConfig();
ForumConfig.prototype.constructor = ForumConfig;
ForumConfig.constructor = ForumConfig;

/**
 * This object models a forum post.
 * It can be used from a forum UI, or with the Libre Web API.
 * It can convert itself to/from XML for web API usage.
 * You must set the forum id as the forum of the forum post.
 * A forum post that has a parent (parent forum post id) is a reply.
 * @class
 * @property id
 * @property topic
 * @property summary
 * @property details
 * @property detailsText
 * @property forum
 * @property tags
 * @property isAdmin
 * @property isFlagged
 * @property flaggedReason
 * @property isFeatured
 * @property creator
 * @property creationDate
 * @property views
 * @property dailyViews
 * @property weeklyViews
 * @property monthlyViews
 * @property replyCount
 * @property parent
 * @property replies
 */
function ForumPostConfig() {	
	this.id;
	this.topic;
	this.summary;
	this.details;
	this.detailsText;
	this.forum;
	this.tags;
	this.isAdmin;
	this.isFlagged;
	this.flaggedReason;
	this.isFeatured;
	this.creator;
	this.creationDate;
	this.views;
	this.dailyViews;
	this.weeklyViews;
	this.monthlyViews;
	this.replyCount;
	this.parent;
	this.avatar;
	this.replies;
	
	this.toXML = function() {
		var xml = "<forum-post";
		xml = this.writeCredentials(xml);
		if (this.id != null) {
			xml = xml + (" id=\"" + this.id + "\"");
		}
		if (this.parent != null) {
			xml = xml + (" parent=\"" + this.parent + "\"");
		}
		if (this.forum != null) {
			xml = xml + (" forum=\"" + this.forum + "\"");
		}
		if (this.isFeatured) {
			xml = xml + (" isFeatured=\"true\"");
		}
		xml = xml + (">");
		if (this.topic != null) {
			xml = xml + ("<topic>");
			xml = xml + (SDK.escapeHTML(this.topic));
			xml = xml + ("</topic>");
		}
		if (this.details != null) {
			xml = xml + ("<details>");
			xml = xml + (SDK.escapeHTML(this.details));
			xml = xml + ("</details>");
		}
		if (this.tags != null) {
			xml = xml + ("<tags>");
			xml = xml + (SDK.escapeHTML(this.tags));
			xml = xml + ("</tags>");
		}
		xml = xml + ("</forum-post>");
	}
	
	this.parseXML = function(element) {
		this.id = element.getAttribute("id");
		this.parent = element.getAttribute("parent");
		this.forum = element.getAttribute("forum");
		this.views = element.getAttribute("views");
		this.dailyViews = element.getAttribute("dailyViews");
		this.weeklyViews = element.getAttribute("weeklyViews");
		this.monthlyViews = element.getAttribute("monthlyViews");
		this.isAdmin = element.getAttribute("isAdmin");
		this.replyCount = element.getAttribute("replyCount");
		this.isFlagged = element.getAttribute("isFlagged");
		this.isFeatured = element.getAttribute("isFeatured");
		this.creator = element.getAttribute("creator");
		this.creationDate = element.getAttribute("creationDate");
		
		var node = element.getElementsByTagName("summary")[0];
		if (node != null) {
			this.summary = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("details")[0];
		if (node != null) {
			this.details = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("detailsText")[0];
		if (node != null) {
			this.detailsText = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("topic")[0];
		if (node != null) {
			this.topic = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("tags")[0];
		if (node != null) {
			this.tags = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("flaggedReason")[0];
		if (node != null) {
			this.flaggedReason = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("avatar")[0];
		if (node != null) {
			this.avatar = SDK.innerHTML(node);
		}
		var nodes = element.getElementsByTagName("replies");
		if (nodes != null && nodes.length > 0) {
			this.replies = [];
			for (var index = 0; index < nodes.length; index++) {
				var reply = nodes[index];
				var config = new ForumPostConfig();
				config.parseXML(reply);
				this.replies[replies.length] = (config);
			}
		}
	}
}
ForumPostConfig.prototype = new Config();
ForumPostConfig.prototype.constructor = ForumPostConfig;
ForumPostConfig.constructor = ForumPostConfig;

/**
 * The Instance config object defines the settings for a bot instance.
 * It is used to create, edit, and reference a bot.
 * It inherits from the WebMediumConfig class.
 * @see {@link WebMediumConfig}
 * @class
 * @property size
 * @property allowForking
 * @property template
 */
function InstanceConfig() {
	/** Read-only : the current size of the bot's knowledge base. **/
	this.size;
	/** Sets if the bot can be forked. */
	this.allowForking;
	/** Sets the name or id of a bot to clone to create a new bot. */
	this.template;
	
	this.type = "instance";
	
	this.credentials = function() {
		var config = new InstanceConfig();
		config.id = this.id;
		return config;
	}
	
	this.toXML = function() {
		var xml = "<instance";
		if (this.allowForking) {
			xml = xml + (" allowForking=\"true\"");
		}
		xml = this.writeWebMediumXML(xml);
		if (this.template != null) {
			xml = xml + ("<template>");
			xml = xml + (this.template);
			xml = xml + ("</template>");
		}
		xml = xml + ("</instance>");
		return xml;
	}
	
	this.parseXML = function(element) {
		this.parseWebMediumXML(element);
		this.allowForking = element.getAttribute("allowForking");
		this.size = element.getAttribute("size");
		
		var node = element.getElementsByTagName("template")[0];
		if (node != null) {
			this.template = SDK.innerHTML(node);
		}
	}
}
InstanceConfig.prototype = new WebMediumConfig();
InstanceConfig.prototype.constructor = InstanceConfig;
InstanceConfig.constructor = InstanceConfig;

/**
 * The Media config object is used the send and retrieve image, video, audio, and file attachments with the server.
 * Media and file attachments can be sent linked in chat messages or forum posts.
 * It inherits from the Config class.
 * @see {@link Config}
 * @class
 * @property id
 * @property name
 * @property type
 * @property file
 * @property key
 */
function MediaConfig() {
	this.id;	
	this.name;
	this.type;
	this.file;
	this.key;
	
	this.parseXML = function (element) {		
		this.id = element.getAttribute("id");
		this.name = element.getAttribute("name");
		this.type = element.getAttribute("type");
		this.file = element.getAttribute("file");
		this.key = element.getAttribute("key");
	}
	
	this.toXML = function() {
		var xml = "<media";
		xml = this.writeCredentials(xml);

		if (this.id != null) {
			xml = xml + (" id=\"" + this.id + "\"");
		}
		if (this.name != null) {
			xml = xml + (" name=\"" + this.name + "\"");
		}
		if (this.file != null) {
			xml = xml + (" file=\"" + this.file + "\"");
		}
		if (this.key != null) {
			xml = xml + (" key=\"" + this.key + "\"");
		}
		
		xml = xml + ("/>");
		return xml;
	}
}
MediaConfig.prototype = new Config();
MediaConfig.prototype.constructor = MediaConfig;
MediaConfig.constructor = MediaConfig;

/**
 * The Voice config object allows the bot's voice to be configured.
 * It inherits from the Config class.
 * @see {@link Config} Config
 * @class
 * @property language
 * @property pitch
 * @property speechRate
 */
function VoiceConfig() {
	/** Voice language code (en, fr, en_US, etc.) */
	this.language;
	this.pitch;
	this.speechRate;
	
	this.parseXML = function (element) {		
		this.language = element.getAttribute("language");
		this.pitch = element.getAttribute("pitch");
		this.speechRate = element.getAttribute("speechRate");
	}

	
	this.toXML = function() {
		var xml = "<voice";
		xml = this.writeCredentials(xml);

		if (this.language != null) {
			xml = xml + (" language=\"" + this.language + "\"");
		}
		if (this.pitch != null) {
			xml = xml + (" pitch=\"" + this.pitch + "\"");
		}
		if (this.speechRate != null) {
			xml = xml + (" speechRate=\"" + this.speechRate + "\"");
		}
		
		xml = xml + ("/>");
		return xml;
	}
}
VoiceConfig.prototype = new Config();
VoiceConfig.prototype.constructor = VoiceConfig;
VoiceConfig.constructor = VoiceConfig;

/**
 * The Training config object allows new responses to be added to the bot.
 * It supports four operations, AddGreeting, RemoveGreeting, AddDefaultResponse, RemoveDefaultResponse, and AddResponse.
 * It inherits from the Config class.
 * @see {@link Config} Config
 * @class
 * @property operation
 * @property question
 * @property response
 */
function TrainingConfig() {
	/** Type of response ("Response", "Greeting", "DefaultResponse"). */
	this.operation;
	/** The question phrase or pattern (i.e. "hello", "what is your name", "Pattern:^ help ^"). */
	this.question;
	/** The response phrase or formula (i.e. "Hello there.", "Formula:"My name is {:target}."", "What would you like help with?"). */
	this.response;
	
	this.parseXML = function (element) {		
		this.operation = element.getAttribute("operation");
		var node = element.getElementsByTagName("question")[0];
		if (node != null) {
			this.question = SDK.innerHTML(node);
		}
		node = element.getElementsByTagName("response")[0];
		if (node != null) {
			this.response = SDK.innerHTML(node);
		}
	}
	
	this.toXML = function() {
		var xml = "<training";
		xml = this.writeCredentials(xml);

		if (this.operation != null) {
			xml = xml + (" operation=\"" + this.operation + "\"");
		}
		xml = xml + (">");
		if (this.question != null) {
			xml = xml + ("<question>");
			xml = xml + (SDK.escapeHTML(this.question));
			xml = xml + ("</question>");
		}
		if (this.response != null) {
			xml = xml + ("<response>");
			xml = xml + (SDK.escapeHTML(this.response));
			xml = xml + ("</response>");
		}
		xml = xml + ("</training>");
		
		xml = xml + ("/>");
		return xml;
	}
}
TrainingConfig.prototype = new Config();
TrainingConfig.prototype.constructor = TrainingConfig;
TrainingConfig.constructor = TrainingConfig;

/**
 * Allow async loading callback.
 */
if (typeof SDK_onLoaded !== 'undefined') {
	SDK_onLoaded();
}

/**
 * Allow for botlibre.SDK namespace.
 */
var botlibre = {};
botlibre.SDK = {};
for (var attr in SDK) {
    botlibre.SDK[attr] = SDK[attr];
}